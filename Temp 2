



// src/components/SummaryCards.js

import React from 'react';
import './SummaryCards.css';
import MyChart from './Chart';
import { Card, CardContent, Typography, Grid } from '@mui/material';

const REJECTION_COLORS = [
  '#007bff', '#28a745', '#ffc107',
  '#dc3545', '#6f42c1', '#17a2b8',
  '#fd7e14', '#20c997', '#6c757d',
  '#6610f2'
];
const PRIORITY_COLORS = { Low: '#90ee90', Medium: '#ffff00', High: '#ff0000' };

function getRejectionStats(summary, rawAlarms, filters) {
  let entries = Object.entries(summary.rejectionTypeWise);
  if (filters.region && !filters.location) {
    const total = summary.regionWise[filters.region].count;
    const byType = rawAlarms
      .filter(a => a.Region === filters.region)
      .reduce((acc, a) => {
        acc[a.Rejection] = (acc[a.Rejection] || 0) + 1;
        return acc;
      }, {});
    entries = Object.entries(byType).map(
      ([t, c]) => [t, { count: c, percentage: `${((c / total) * 100).toFixed(2)}%` }]
    );
  }
  if (filters.location) {
    const total = summary.locationWise[filters.location]?.count || 0;
    const byType = rawAlarms
      .filter(a => a.Region === filters.region && a.Location === filters.location)
      .reduce((acc, a) => {
        acc[a.Rejection] = (acc[a.Rejection] || 0) + 1;
        return acc;
      }, {});
    entries = Object.entries(byType).map(
      ([t, c]) => [t, { count: c, percentage: `${((c / total) * 100).toFixed(2)}%` }]
    );
  }
  return entries
    .map(([type, info], idx) => ({
      type,
      count: info.count,
      percentage: info.percentage,
      color: REJECTION_COLORS[idx % REJECTION_COLORS.length]
    }))
    .sort((a, b) => b.count - a.count);
}

export default function SummaryCards({ summary, filters, rawAlarms }) {
  if (!summary) return null;
  const rejectionStats = getRejectionStats(summary, rawAlarms, filters);

  // Priority stats (unchanged)
  const filtered = rawAlarms.filter(a => {
    if (filters.region && a.Region !== filters.region) return false;
    if (filters.location && a.Location !== filters.location) return false;
    if (filters.month && !a.Date.startsWith(filters.month)) return false;
    return true;
  });
  const prCounts = filtered.reduce((acc, a) => {
    const p = a['CCURE Incident Priority'];
    acc[p] = (acc[p] || 0) + 1;
    return acc;
  }, {});
  const prLabels = Object.keys(prCounts);
  const prValues = prLabels.map(l => prCounts[l]);
  const prColors = prLabels.map(l => PRIORITY_COLORS[l] || '#ccc');

  const makeChartData = (obj, palette) => {
    const labels = Object.keys(obj);
    const values = labels.map(l => obj[l].count);
    const colors = labels.map((_, i) => palette[i % palette.length]);
    return { labels, values, bgColors: colors, borderColor: colors };
  };

  // **NEW:** Re-compute per-region counts honoring month & location filters
  const dynamicRegionCounts = rawAlarms
    .filter(a => {
      if (filters.location && a.Location !== filters.location) return false;
      if (filters.month && !a.Date.startsWith(filters.month)) return false;
      return true;
    })
    .reduce((acc, a) => {
      acc[a.Region] = (acc[a.Region] || 0) + 1;
      return acc;
    }, {});

  const partitionObj = filters.region
    ? { [filters.region]: { count: dynamicRegionCounts[filters.region] || 0 } }
    : Object.entries(dynamicRegionCounts).reduce((acc, [r, c]) => {
        acc[r] = { count: c };
        return acc;
      }, {});

  return (
    <>
      {/* Rejection Cards */}
      <Grid container spacing={2} sx={{ mb: 2 }}>
        {rejectionStats.map(({ type, count, percentage, color }) => (
          <Grid item xs={12} sm={6} md={3} key={type}>
            <Card sx={{ border: `2px solid ${color}`, backgroundColor: color, color: '#fff' }}>
              <CardContent>
                <Typography variant="subtitle2">{type}</Typography>
                <Typography variant="h6">{count}</Typography>
                <Typography variant="body2">{percentage}</Typography>
              </CardContent>
            </Card>
          </Grid>
        ))}
      </Grid>

      {/* Three charts per row */}
      <Grid container spacing={2} sx={{ mb: 4 }}>
        {[partitionObj, summary.locationWise, summary.operatorWise].map((obj, idx) => {
          const titles = ['Global Partition', 'Location Wise', 'Operator Wise'];
          const types  = ['doughnut', 'line', 'bar'];
          if (!obj || !Object.keys(obj).length) return null;
          return (
            <Grid item xs={12} md={4} key={titles[idx]}>
              <Card sx={{ border: '1px solid #ccc' }}>
                <CardContent>
                  <Typography variant="h6" gutterBottom>
                    {titles[idx]}
                  </Typography>
                  <MyChart
                    type={types[idx]}
                    data={makeChartData(obj, REJECTION_COLORS)}
                    options={
                      idx === 1
                        ? {
                            scales: {
                              x: { title: { display: true, text: 'Location' } },
                              y: { title: { display: true, text: 'Count' } }
                            }
                          }
                        : {}
                    }
                    height={250}
                  />
                </CardContent>
              </Card>
            </Grid>
          );
        })}
      </Grid>

      {/* Last row: Priority & Month */}
      <Grid container spacing={2}>
        <Grid item xs={12} md={4}>
          <Card sx={{ border: '1px solid #ccc' }}>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                Priority Wise
              </Typography>
              <MyChart
                type="pie"
                data={{
                  labels: prLabels,
                  values: prValues,
                  bgColors: prColors,
                  borderColor: prColors
                }}
                height={250}
              />
            </CardContent>
          </Card>
        </Grid>
        <Grid item xs={12} md={4}>
          <Card sx={{ border: '1px solid #ccc' }}>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                Month Wise
              </Typography>
              <MyChart
                type="line"
                data={makeChartData(summary.monthWise, REJECTION_COLORS)}
                options={{
                  scales: {
                    x: { title: { display: true, text: 'Month' } },
                    y: { title: { display: true, text: 'Count' } }
                  }
                }}
                height={250}
              />
            </CardContent>
          </Card>
        </Grid>
      </Grid>
    </>
  );
}










// src/pages/Dashboard.js

import React, { useEffect, useState, useMemo, useRef } from 'react';
import { Box, Container, Typography, Link as MuiLink } from '@mui/material';
import { Link } from 'react-router-dom';
import Filters from '../components/Filters';
import AlarmCard from '../components/AlarmCard';
import SummaryCards from '../components/SummaryCards';
import { getAlarmSummary, getRawAlarms } from '../services/api';

export default function Dashboard() {
  const [summary, setSummary]     = useState(null);
  const [rawAlarms, setRawAlarms] = useState([]);
  const [filters, setFilters]     = useState({ region: '', location: '', month: '' });

  // Fetch data once
  useEffect(() => {
    Promise.all([getAlarmSummary(), getRawAlarms()])
      .then(([sumRes, rawRes]) => {
        setSummary(sumRes.data);
        setRawAlarms(rawRes.data);
      })
      .catch(console.error);
  }, []);

  // Region options
  const regionOptions = useMemo(
    () => (summary ? Object.keys(summary.regionWise) : []),
    [summary]
  );

  // Location options
  const locationOptions = useMemo(() => {
    if (!filters.region) return [];
    return Array.from(
      new Set(
        rawAlarms
          .filter(a => a.Region === filters.region)
          .map(a => a.Location)
      )
    );
  }, [rawAlarms, filters.region]);

  // Month options
  const monthOptions = useMemo(() => {
    const months = new Set(
      rawAlarms.map(a => {
        const [d, mon, yy] = a.Date.split('-');
        const m = String("JanFebMarAprMayJunJulAugSepOctNovDec".indexOf(mon) / 3 + 1).padStart(2, '0');
        return `${m}-20${yy}`;
      })
    );
    return [...months];
  }, [rawAlarms]);

  // Build slides: global + per-region
  const slidesRef = useRef([]);
  const slideIdx  = useRef(0);
  useEffect(() => {
    if (!summary) return;
    const slides = [{ region: '', location: '', month: '' }];
    regionOptions.forEach(r => slides.push({ region: r, location: '', month: '' }));
    slidesRef.current = slides;
    slideIdx.current    = 0;
    setFilters(slides[0]);

    const id = setInterval(() => {
      slideIdx.current = (slideIdx.current + 1) % slidesRef.current.length;
      setFilters(slidesRef.current[slideIdx.current]);
    }, 30000);

    return () => clearInterval(id);
  }, [summary, regionOptions]);

  // **NEW:** Manual advance on title click
  const handleTitleClick = () => {
    slideIdx.current = (slideIdx.current + 1) % slidesRef.current.length;
    setFilters(slidesRef.current[slideIdx.current]);
  };

  if (!summary) {
    return <Typography>Loading dashboardâ€¦</Typography>;
  }

  return (
    <Box sx={{ width: '100vw', height: '100vh', bgcolor: '#fafafa', p: 0, m: 0 }}>
      <Container maxWidth={false} disableGutters>

        {/* Heading Bar (click title to advance region) */}
        <Box
          sx={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            borderBottom: '2px solid #000',
            py: 2,
            mb: 3,
            position: 'relative'
          }}
        >
          <Typography
            variant="h3"
            component="h1"
            onClick={handleTitleClick}
            sx={{ mx: 4, cursor: 'pointer', userSelect: 'none' }}
            title="Click to advance region"
          >
            ðŸ”” Alarm Analysis Dashboard
          </Typography>
          <Box sx={{ position: 'absolute', left: 16 }}>
            <MuiLink component={Link} to="/" sx={{ mx: 1 }}>
              Dashboard
            </MuiLink>
            <MuiLink component={Link} to="/alarms" sx={{ mx: 1 }}>
              Raw Alarms
            </MuiLink>
          </Box>
        </Box>

        {/* Filters */}
        <Box sx={{ px: 2 }}>
          <Filters
            filters={filters}
            setFilters={setFilters}
            regionOptions={regionOptions}
            locationOptions={locationOptions}
            monthOptions={monthOptions}
          />
        </Box>

        {/* Summary Cards */}
        <Box sx={{ px: 2 }}>
          <AlarmCard summary={summary} rawAlarms={rawAlarms} filters={filters} />
        </Box>

        {/* Charts (edge-to-edge) */}
        <Box sx={{ flex: 1, overflowY: 'auto', width: '100vw', p: 0, m: 0 }}>
          <SummaryCards summary={summary} filters={filters} rawAlarms={rawAlarms} />
        </Box>
      </Container>
    </Box>
  );
}









// src/components/SummaryCards.js
@@
-export default function SummaryCards({ summary, filters, rawAlarms }) {
+export default function SummaryCards({ summary, filters, rawAlarms }) {
   if (!summary) return null;
   const rejectionStats = getRejectionStats(summary, rawAlarms, filters);
@@
   // Priority
   const filtered = rawAlarms.filter(a => {
@@
   // build dynamic partition (was static summary.regionWise)
-  const partitionObj = !filters.region
-    ? summary.regionWise
-    : { [filters.region]: summary.regionWise[filters.region] };
+  // Re-compute region counts honoring month & location filters
+  const dynamicRegionCounts = rawAlarms
+    .filter(a => {
+      if (filters.location && a.Location !== filters.location) return false;
+      if (filters.month && !a.Date.startsWith(filters.month)) return false;
+      return true;
+    })
+    .reduce((acc, a) => {
+      acc[a.Region] = (acc[a.Region] || 0) + 1;
+      return acc;
+    }, {});
+
+  const partitionObj = filters.region
+    ? { [filters.region]: { count: dynamicRegionCounts[filters.region] || 0 } }
+    : Object.entries(dynamicRegionCounts).reduce((acc, [r, c]) => {
+        acc[r] = { count: c };
+        return acc;
+      }, {});
@@
       {[partitionObj, summary.locationWise, summary.operatorWise].map((obj, idx) => {
         const titles = ['Global Partition','Location Wise','Operator Wise'];
         const types  = ['doughnut','line','bar'];
-        if (!obj || !Object.keys(obj).length) return null;
+        if (!obj || !Object.keys(obj).length) return null;
         return (
           <Grid item xs={12} md={4} key={titles[idx]}>
             <Card sx={{ border:'1px solid #ccc' }}>
               <CardContent>
-                <Typography variant="h6" gutterBottom>
+                <Typography variant="h6" gutterBottom>
                   {titles[idx]}
                 </Typography>
-                <MyChart
+                <MyChart
                   type={types[idx]}
-                  data={makeChartData(obj, REJECTION_COLORS)}
+                  data={makeChartData(obj, REJECTION_COLORS)}
                   options={idx===1?{
                     scales:{
                       x:{title:{display:true,text:'Location'}},
                       y:{title:{display:true,text:'Count'}}






// src/pages/Dashboard.js
@@ export default function Dashboard() {
-  useEffect(() => {
+  useEffect(() => {
     if (!summary) return;
     const slides = [{ region:'', location:'', month:'' }];
@@
     return () => clearInterval(id);
   }, [summary, regionOptions]);

+  // Manual advance on header click:
+  const handleTitleClick = () => {
+    slideIdx.current =
+      (slideIdx.current + 1) % slidesRef.current.length;
+    setFilters(slidesRef.current[slideIdx.current]);
+  };

   if (!summary) {
     return <Typography>Loading dashboardâ€¦</Typography>;
   }

   return (
@@
-        {/* Heading Bar */}
+        {/* Heading Bar (click title to manually advance region) */}
         <Box
           sx={{
             display:'flex',
             alignItems:'center',
             justifyContent:'center',
             borderBottom:'2px solid #000',
             py:2,
             mb:3,
             position:'relative'
           }}
         >
-          <Typography variant="h3" component="h1" sx={{ mx:4 }}>
+          <Typography
+            variant="h3"
+            component="h1"
+            onClick={handleTitleClick}
+            sx={{ mx:4, cursor:'pointer', userSelect:'none' }}
+            title="Click to advance region"
+          >
             ðŸ”” Alarm Analysis Dashboard
           </Typography>
           <Box sx={{ position:'absolute', left:16 }}>
@@
-        {/* Charts */}
-        <Box sx={{ flex:1, overflowY:'auto', px:2, pb:4 }}>
-          <SummaryCards summary={summary} filters={filters} rawAlarms={rawAlarms} />
-        </Box>
+        {/* Charts (edge-to-edge) */}
+        <Box sx={{ flex:1, overflowY:'auto', width:'100vw', p:0, m:0 }}>
+          <SummaryCards summary={summary} filters={filters} rawAlarms={rawAlarms} />
+        </Box>






read Once File carefully .
issue is 1) charts are not update as per Filtered Region
Issue 2) charts Layout Are not Spread On Full Scrren .Display Charta On full Screen.
Also Make Heading Section Interactive .
make sure dont change another Function 

Kindly read each file carefully and make changes and give me Updated js file carefully.

File 1 

AlarmCard.js



import React from 'react';
import { Card, CardContent, Typography, Grid } from '@mui/material';

export default function AlarmCard({ summary, rawAlarms, filters }) {
  if (!summary) return null;

  // Compute dynamic total:
  const totalAlarms = rawAlarms.filter(a => {
    if (filters.region && a.Region !== filters.region) return false;
    if (filters.location && a.Location !== filters.location) return false;
    if (filters.month && !a.Date.startsWith(filters.month)) return false;
    return true;
  }).length;

  // Compute dynamic responseSentPercentage:
  const sentCount = rawAlarms.filter(a => {
    if (filters.region && a.Region !== filters.region) return false;
    if (filters.location && a.Location !== filters.location) return false;
    if (filters.month && !a.Date.startsWith(filters.month)) return false;
    return a['Action Taken'] && a['Action Taken'] !== 'Not Sent';
  }).length;
  const responseSentPercentage = totalAlarms
    ? `${((sentCount / totalAlarms) * 100).toFixed(2)}%`
    : '0%';

  return (
    <Grid container spacing={2} sx={{ mb: 3 }}>
      <Grid item xs={12} sm={6} md={4}>
        <Card>
          <CardContent>
            <Typography variant="subtitle1" gutterBottom>
              Total Alarms
            </Typography>
            <Typography variant="h4">{totalAlarms}</Typography>
          </CardContent>
        </Card>
      </Grid>
      <Grid item xs={12} sm={6} md={4}>
        <Card>
          <CardContent>
            <Typography variant="subtitle1" gutterBottom>
              Response Sent %
            </Typography>
            <Typography variant="h4">{responseSentPercentage}</Typography>
          </CardContent>
        </Card>
      </Grid>
    </Grid>
  );
}




file 2

Charts.js


import React, { useEffect, useRef } from 'react';
import Chart from 'chart.js/auto';

export default function MyChart({
  type = 'bar',
  data,
  options = {},
  width = '100%',
  height = 400
}) {
  const canvasRef = useRef(null);
  const chartRef  = useRef(null);

  useEffect(() => {
    if (!canvasRef.current) return;
    const ctx = canvasRef.current.getContext('2d');
    if (chartRef.current) chartRef.current.destroy();

    // Build dataset with line-chart specifics if needed
    const ds = {
      label: data.label || '',
      data: data.values,
      backgroundColor: data.bgColors,
      borderColor: data.borderColor,
      borderWidth: 2,
      fill: type === 'line' ? false : true,
      tension: type === 'line' ? 0.4 : 0,
      pointBackgroundColor: data.borderColor,
      pointRadius: type === 'line' ? 4 : undefined,
    };

    chartRef.current = new Chart(ctx, {
      type,
      data: {
        labels: data.labels,
        datasets: [ds],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        ...options,
      }
    });

    return () => chartRef.current && chartRef.current.destroy();
  }, [type, data, options]);

  return (
    <div style={{ width, height }}>
      <canvas ref={canvasRef} />
    </div>
  );
}




File 3

Filters.js


import React from 'react';
import { TextField, MenuItem, Box } from '@mui/material';

const Filters = ({
  filters,
  setFilters,
  regionOptions = [],
  locationOptions = [],
  monthOptions = []
}) => {
  const handleChange = field => e =>
    setFilters(prev => ({
      ...prev,
      [field]: e.target.value,
      ...(field === 'region' && { location: '' })
    }));

  return (
    <Box
      sx={{
        display: 'flex',
        gap: 2,
        flexWrap: 'wrap',
        mb: 3
      }}
    >
      <TextField
        select
        label="Region"
        value={filters.region}
        onChange={handleChange('region')}
        size="small"
      >
        <MenuItem value="">Global</MenuItem>
        {regionOptions.map(r => (
          <MenuItem key={r} value={r}>{r}</MenuItem>
        ))}
      </TextField>

      {filters.region && (
        <TextField
          select
          label="Location"
          value={filters.location}
          onChange={handleChange('location')}
          size="small"
        >
          <MenuItem value="">All Locations</MenuItem>
          {locationOptions.map(l => (
            <MenuItem key={l} value={l}>{l}</MenuItem>
          ))}
        </TextField>
      )}

      <TextField
        select
        label="Month"
        value={filters.month}
        onChange={handleChange('month')}
        size="small"
      >
        <MenuItem value="">All Months</MenuItem>
        {monthOptions.map(m => (
          <MenuItem key={m} value={m}>{m}</MenuItem>
        ))}
      </TextField>
    </Box>
  );
};

export default Filters;



File 4

SummaryCards.js



import React from 'react';
import './SummaryCards.css';
import MyChart from './Chart';
import { Card, CardContent, Typography, Grid } from '@mui/material';

const REJECTION_COLORS = [
  '#007bff', '#28a745', '#ffc107',
  '#dc3545', '#6f42c1', '#17a2b8',
  '#fd7e14', '#20c997', '#6c757d',
  '#6610f2'
];
const PRIORITY_COLORS = { Low: '#90ee90', Medium: '#ffff00', High: '#ff0000' };

function getRejectionStats(summary, rawAlarms, filters) {
  let entries = Object.entries(summary.rejectionTypeWise);
  if (filters.region && !filters.location) {
    const total = summary.regionWise[filters.region].count;
    const byType = rawAlarms.filter(a => a.Region === filters.region)
      .reduce((acc, a) => {
        acc[a.Rejection] = (acc[a.Rejection]||0)+1;
        return acc;
      }, {});
    entries = Object.entries(byType).map(([t,c])=>[t,{count:c,percentage:`${((c/total)*100).toFixed(2)}%`}]);
  }
  if (filters.location) {
    const total = summary.locationWise[filters.location]?.count||0;
    const byType = rawAlarms.filter(a=>a.Region===filters.region&&a.Location===filters.location)
      .reduce((acc,a)=>{acc[a.Rejection]=(acc[a.Rejection]||0)+1;return acc;}, {});
    entries = Object.entries(byType).map(([t,c])=>[t,{count:c,percentage:`${((c/total)*100).toFixed(2)}%`}]);
  }
  return entries
    .map(([type, info], idx) => ({
      type,
      count: info.count,
      percentage: info.percentage,
      color: REJECTION_COLORS[idx % REJECTION_COLORS.length]
    }))
    .sort((a,b)=>b.count - a.count);
}

export default function SummaryCards({ summary, filters, rawAlarms }) {
  if (!summary) return null;
  const rejectionStats = getRejectionStats(summary, rawAlarms, filters);

  // Priority
  const filtered = rawAlarms.filter(a => {
    if (filters.region && a.Region!==filters.region) return false;
    if (filters.location && a.Location!==filters.location) return false;
    if (filters.month && !a.Date.startsWith(filters.month)) return false;
    return true;
  });
  const prCounts = filtered.reduce((acc,a)=>{
    acc[a['CCURE Incident Priority']] = (acc[a['CCURE Incident Priority']]||0)+1;
    return acc;
  },{});
  const prLabels = Object.keys(prCounts);
  const prValues = prLabels.map(l=>prCounts[l]);
  const prColors = prLabels.map(l=>PRIORITY_COLORS[l]||'#ccc');

  const makeChartData = (obj, palette) => {
    const labels = Object.keys(obj);
    const values = labels.map(l => obj[l].count);
    const colors = labels.map((_,i)=>palette[i%palette.length]);
    return { labels, values, bgColors:colors, borderColor:colors };
  };

  const partitionObj = !filters.region
    ? summary.regionWise
    : { [filters.region]: summary.regionWise[filters.region] };

  return (
    <>
      {/* Rejection Cards */}
      <Grid container spacing={2} sx={{ mb: 2 }}>
        {rejectionStats.map(({type,count,percentage,color})=>(
          <Grid item xs={12} sm={6} md={3} key={type}>
            <Card sx={{ border:`2px solid ${color}`, backgroundColor:color, color:'#fff' }}>
              <CardContent>
                <Typography variant="subtitle2">{type}</Typography>
                <Typography variant="h6">{count}</Typography>
                <Typography variant="body2">{percentage}</Typography>
              </CardContent>
            </Card>
          </Grid>
        ))}
      </Grid>

      {/* Three charts per row */}
      <Grid container spacing={2} sx={{ mb:4 }}>
        {[partitionObj, summary.locationWise, summary.operatorWise].map((obj, idx) => {
          const titles = ['Global Partition','Location Wise','Operator Wise'];
          const types  = ['doughnut','line','bar'];
          if (!obj || !Object.keys(obj).length) return null;
          return (
            <Grid item xs={12} md={4} key={titles[idx]}>
              <Card sx={{ border:'1px solid #ccc' }}>
                <CardContent>
                  <Typography variant="h6" gutterBottom>
                    {titles[idx]}
                  </Typography>
                  <MyChart
                    type={types[idx]}
                    data={makeChartData(obj, REJECTION_COLORS)}
                    options={idx===1?{
                      scales:{
                        x:{title:{display:true,text:'Location'}},
                        y:{title:{display:true,text:'Count'}}
                      }
                    }:{}}
                    height={250}
                  />
                </CardContent>
              </Card>
            </Grid>
          );
        })}
      </Grid>

      {/* Last row: Priority & Month & leftover */}
      <Grid container spacing={2}>
        <Grid item xs={12} md={4}>
          <Card sx={{ border:'1px solid #ccc' }}>
            <CardContent>
              <Typography variant="h6" gutterBottom>Priority Wise</Typography>
              <MyChart
                type="pie"
                data={{ labels:prLabels, values:prValues, bgColors:prColors, borderColor:prColors }}
                height={250}
              />
            </CardContent>
          </Card>
        </Grid>
        <Grid item xs={12} md={4}>
          <Card sx={{ border:'1px solid #ccc' }}>
            <CardContent>
              <Typography variant="h6" gutterBottom>Month Wise</Typography>
              <MyChart
                type="line"
                data={makeChartData(summary.monthWise, REJECTION_COLORS)}
                options={{
                  scales:{
                    x:{title:{display:true,text:'Month'}},
                    y:{title:{display:true,text:'Count'}}
                  }
                }}
                height={250}
              />
            </CardContent>
          </Card>
        </Grid>
        {/* If you have a 6th chart, insert it here in the third md=4 slot */}
      </Grid>
    </>
  );
}





file 5


dashboard.js



import React, { useEffect, useState, useMemo, useRef } from 'react';
import { Box, Container, Typography, Link as MuiLink } from '@mui/material';
import { Link } from 'react-router-dom';
import Filters from '../components/Filters';
import AlarmCard from '../components/AlarmCard';
import SummaryCards from '../components/SummaryCards';
import { getAlarmSummary, getRawAlarms } from '../services/api';

export default function Dashboard() {
  const [summary, setSummary]     = useState(null);
  const [rawAlarms, setRawAlarms] = useState([]);
  const [filters, setFilters]     = useState({ region: '', location: '', month: '' });

  // Fetch data once
  useEffect(() => {
    Promise.all([getAlarmSummary(), getRawAlarms()])
      .then(([sumRes, rawRes]) => {
        setSummary(sumRes.data);
        setRawAlarms(rawRes.data);
      })
      .catch(console.error);
  }, []);

  // Region options
  const regionOptions = useMemo(() =>
    summary ? Object.keys(summary.regionWise) : []
  , [summary]);

  // Location options
  const locationOptions = useMemo(() => {
    if (!filters.region) return [];
    return Array.from(new Set(
      rawAlarms.filter(a => a.Region === filters.region).map(a => a.Location)
    ));
  }, [rawAlarms, filters.region]);

  // Month options
  const monthOptions = useMemo(() => {
    const months = new Set(rawAlarms.map(a => {
      const [d,mon,yy] = a.Date.split('-');
      const m = String("JanFebMarAprMayJunJulAugSepOctNovDec".indexOf(mon)/3+1).padStart(2,'0');
      return `${m}-20${yy}`;
    }));
    return [...months];
  }, [rawAlarms]);

  // Build slideshow slides: global + region
  const slidesRef = useRef([]);
  const slideIdx  = useRef(0);
  useEffect(() => {
    if (!summary) return;
    const slides = [{ region:'', location:'', month:'' }];
    regionOptions.forEach(r => slides.push({ region:r, location:'', month:'' }));
    slidesRef.current = slides;
    slideIdx.current    = 0;
    setFilters(slides[0]);

    const id = setInterval(() => {
      slideIdx.current = (slideIdx.current + 1) % slidesRef.current.length;
      setFilters(slidesRef.current[slideIdx.current]);
    }, 30000);

    return () => clearInterval(id);
  }, [summary, regionOptions]);

  if (!summary) {
    return <Typography>Loading dashboardâ€¦</Typography>;
  }

  return (
    <Box sx={{ width:'100vw', height:'100vh', bgcolor:'#fafafa', p:0, m:0 }}>
      <Container maxWidth={false} disableGutters>
        {/* Heading Bar */}
        <Box
          sx={{
            display:'flex',
            alignItems:'center',
            justifyContent:'center',
            borderBottom:'2px solid #000',
            py:2,
            mb:3,
            position:'relative'
          }}
        >
          <Typography variant="h3" component="h1" sx={{ mx:4 }}>
            ðŸ”” Alarm Analysis Dashboard
          </Typography>
          <Box sx={{ position:'absolute', left:16 }}>
            <MuiLink component={Link} to="/" sx={{ mx:1 }}>Dashboard</MuiLink>
            <MuiLink component={Link} to="/alarms" sx={{ mx:1 }}>Raw Alarms</MuiLink>
          </Box>
        </Box>

        {/* Filters */}
        <Box sx={{ px:2 }}>
          <Filters
            filters={filters}
            setFilters={setFilters}
            regionOptions={regionOptions}
            locationOptions={locationOptions}
            monthOptions={monthOptions}
          />
        </Box>

        {/* Summary Cards */}
        <Box sx={{ px:2 }}>
          <AlarmCard summary={summary} rawAlarms={rawAlarms} filters={filters} />
        </Box>

        {/* Charts */}
        <Box sx={{ flex:1, overflowY:'auto', px:2, pb:4 }}>
          <SummaryCards summary={summary} filters={filters} rawAlarms={rawAlarms} />
        </Box>
      </Container>
    </Box>
  );
}





File 6


App.js



import React from 'react';
import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';
import { AppBar, Toolbar, Typography, Button } from '@mui/material';
import Dashboard from './pages/Dashboard';
import RawAlarms from './pages/RawAlarms';

export default function App() {
  return (
    <Router>
      <AppBar position="static">
        <Toolbar>
          <Typography variant="h6" sx={{ flexGrow:1 }}>
            AlarmðŸ”” Dashboard
          </Typography>
          <Button color="inherit" component={Link} to="/">Dashboard</Button>
          <Button color="inherit" component={Link} to="/alarms">Raw Alarms</Button>
        </Toolbar>
      </AppBar>
      <Routes>
        <Route path="/" element={<Dashboard />} />
        <Route path="/alarms" element={<RawAlarms />} />
      </Routes>
    </Router>
  );
}

