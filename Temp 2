// src/theme.js
import { createContext, useContext, useMemo, useState } from 'react';
import { createTheme } from '@mui/material/styles';

const ThemeModeContext = createContext();

export function useThemeMode() {
  return useContext(ThemeModeContext);
}

export function ThemeModeProvider({ children }) {
  const [mode, setMode] = useState('light');
  const toggleMode = () => setMode(m => (m === 'light' ? 'dark' : 'light'));

  const theme = useMemo(() => createTheme({
    palette: {
      mode,
      background: {
        default: mode === 'dark' ? '#121212' : '#fafafa',
        paper:   mode === 'dark' ? '#1e1e1e' : '#ffffff'
      },
      text: {
        primary:   mode === 'dark' ? '#ffffff' : '#000000',
        secondary: mode === 'dark' ? '#bbbbbb' : '#333333'
      }
    }
  }), [mode]);

  return (
    <ThemeModeContext.Provider value={{ mode, toggleMode }}>
      {children(theme)}
    </ThemeModeContext.Provider>
  );
}




// src/components/Navbar.js
import React from 'react';
import {
  AppBar, Toolbar, IconButton,
  Typography, Box, Link
} from '@mui/material';
import {
  Dashboard as DashboardIcon,
  Brightness4,
  Brightness7
} from '@mui/icons-material';
import { useTheme } from '@mui/material/styles';
import { useThemeMode } from '../theme';

export default function Navbar() {
  const theme = useTheme();
  const { mode, toggleMode } = useThemeMode();

  return (
    <AppBar position="static" color="default" elevation={1}>
      <Toolbar sx={{ justifyContent: 'space-between' }}>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <DashboardIcon />
          <Typography variant="h6">Alarm Analysis Dashboard</Typography>
        </Box>

        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
          <Link href="/" underline="none" color="inherit">Dashboard</Link>
          <Link href="/alarms" underline="none" color="inherit">Raw Alarms</Link>
        </Box>

        <IconButton onClick={toggleMode} color="inherit">
          {mode === 'dark' ? <Brightness7 /> : <Brightness4 />}
        </IconButton>
      </Toolbar>
    </AppBar>
  );
}








// src/pages/Dashboard.js
import React, { useEffect, useState, useMemo, useRef, useCallback } from 'react';
import {
  Box, Typography, Container, Button,
  IconButton, createTheme, ThemeProvider, CssBaseline
} from '@mui/material';
import DashboardIcon from '@mui/icons-material/Dashboard';
import Brightness4Icon from '@mui/icons-material/Brightness4';
import Brightness7Icon from '@mui/icons-material/Brightness7';
import Filters from '../components/Filters';
import AlarmCard from '../components/AlarmCard';
import SummaryCards from '../components/SummaryCards';
import { getAlarmSummary, getRawAlarms } from '../services/api';
import { Link } from 'react-router-dom';
import html2canvas from 'html2canvas';
const PptxGenJS = require('pptxgenjs');

// helper: convert "01-Apr-25" → "2025-04-01"
function toISODate(apiDate) {
  const [d, monAbbr, yy] = apiDate.split('-');
  const monthNames = {
    Jan: '01', Feb: '02', Mar: '03', Apr: '04',
    May: '05', Jun: '06', Jul: '07', Aug: '08',
    Sep: '09', Oct: '10', Nov: '11', Dec: '12'
  };
  const mm = monthNames[monAbbr] || '01';
  const yyyy = `20${yy}`;
  return `${yyyy}-${mm}-${d.padStart(2, '0')}`;
}

// helper: format month/year for dropdown (e.g. "Apr 25")
function formatMonthYear(apiDate) {
  const [d, monAbbr, yy] = apiDate.split('-');
  return `${monAbbr} ${yy}`;
}

export default function Dashboard() {
  // 1️⃣: theme mode state & theme setup
  const [mode, setMode] = useState('light');
  const toggleTheme = useCallback(() => {
    setMode(m => (m === 'light' ? 'dark' : 'light'));
  }, []);
  const theme = useMemo(() =>
    createTheme({
      palette: {
        mode,
        ...(mode === 'dark'
          ? {
              background: { default: '#121212', paper: '#1e1e1e' },
              text:       { primary: '#fff', secondary: '#bbb' }
            }
          : {
              background: { default: '#fafafa', paper: '#fff' },
              text:       { primary: '#000', secondary: '#333' }
            }
        )
      },
      components: {
        MuiLink: {
          styleOverrides: {
            root: { textDecoration: 'none', color: 'inherit' }
          }
        }
      }
    }),
  [mode]);

  // 2️⃣: data fetch + refs + filters
  const [summary, setSummary]     = useState(null);
  const [rawAlarms, setRawAlarms] = useState([]);
  const [filters, setFilters]     = useState({ region:'',location:'',month:'',date:'',priority:'' });
  const dashRef   = useRef();
  const cardsRef  = useRef();
  const chartsRef = useRef();

  useEffect(() => {
    Promise.all([getAlarmSummary(), getRawAlarms()])
      .then(([sumRes, rawRes]) => {
        setSummary(sumRes.data);
        setRawAlarms(rawRes.data);
      })
      .catch(console.error);
  }, []);

  // 3️⃣: compute dropdown options & filtered data (unchanged)
  const regionOptions = useMemo(() => summary ? Object.keys(summary.regionWise) : [], [summary]);
  const locationOptions = useMemo(() => filters.region
    ? Array.from(new Set(rawAlarms.filter(a=>a.Region===filters.region).map(a=>a.Location)))
    : [], [rawAlarms, filters.region]);
  const monthOptions = useMemo(() => {
    const all = rawAlarms
      .filter(a=>(!filters.region||a.Region===filters.region)&&(!filters.location||a.Location===filters.location))
      .map(a=>formatMonthYear(a.Date));
    return Array.from(new Set(all)).sort((a,b)=>{
      const [mA,yA]=a.split(' '),[mB,yB]=b.split(' ');
      return new Date(`20${yA}-${mA}-01`) - new Date(`20${yB}-${mB}-01`);
    });
  }, [rawAlarms, filters.region, filters.location]);
  const priorityOptions = useMemo(
    () => Array.from(new Set(rawAlarms.map(a=>a['CCURE Incident Priority']))),
    [rawAlarms]
  );
  const filtered = useMemo(() => rawAlarms.filter(a => {
    if(filters.region   && a.Region   !== filters.region) return false;
    if(filters.location && a.Location !== filters.location) return false;
    if(filters.month    && formatMonthYear(a.Date)!==filters.month) return false;
    if(filters.date     && toISODate(a.Date)!==filters.date)       return false;
    if(filters.priority && a['CCURE Incident Priority']!==filters.priority) return false;
    return true;
  }), [rawAlarms, filters]);

  // 4️⃣: build filteredSummary (identical to your logic)
  const filteredSummary = useMemo(() => {
    if (!summary) return null;
    const fs = { ...summary };
    if (filters.region) {
      fs.regionWise   = { [filters.region]: summary.regionWise[filters.region] };
      fs.locationWise = {};
      locationOptions
        .filter(l => !filters.location || l === filters.location)
        .forEach(l => { fs.locationWise[l] = summary.locationWise[l]; });
    }
    if (filters.month) {
      const mCount = filtered.filter(a=>formatMonthYear(a.Date)===filters.month).length;
      fs.monthWise = { [filters.month]: { count: mCount } };
    } else fs.monthWise = {};
    const opCounts = filtered.reduce((c,a)=>{
      const op = a['Name of Person Attending Alarms (First, Last Name)']||'Unknown';
      c[op] = (c[op]||0)+1; return c;
    }, {});
    fs.operatorWise = Object.fromEntries(Object.entries(opCounts).map(([k,v])=>[k,{count:v}]));
    return fs;
  }, [summary, filtered, filters, locationOptions]);

  if (!summary) return <Typography>Loading dashboard…</Typography>;

  // export logic (unchanged)
  const exportSection = async (el, fileName='Full_Dashboard.pptx') => {
    const canvas = await html2canvas(el);
    const imgData = canvas.toDataURL('image/png');
    const ppt = new PptxGenJS();
    const slide = ppt.addSlide();
    slide.addImage({ data: imgData, x:0, y:0, w:'100%', h:'100%' });
    await ppt.writeFile({ fileName });
  };

  // 👉 Render
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />

      {/* top-level Box now uses theme.background.default */}
      <Box
        ref={dashRef}
        sx={{
          width: '100vw',
          minHeight: '100vh',
          bgcolor: 'background.default',
          overflowX: 'hidden'
        }}
      >
        {/* Header */}
        <Box component="header" sx={{
          display: 'flex', alignItems: 'center', justifyContent: 'space-between',
          borderBottom: 1, borderColor: 'divider',
          bgcolor: 'background.paper', p: 2
        }}>
          <Box sx={{ display:'flex', alignItems:'center', gap:1 }}>
            <DashboardIcon fontSize="large"/>
            <Typography variant="h4">Alarm Analysis Dashboard</Typography>
          </Box>
          <Box sx={{ display:'flex', alignItems:'center', gap:2 }}>
            <Link to="/">➤ Dashboard</Link>
            <Link to="/alarms">➤ Raw Alarms</Link>
          </Box>
          <IconButton onClick={toggleTheme}>
            {mode === 'dark' ? <Brightness7Icon/> : <Brightness4Icon/>}
          </IconButton>
        </Box>

        <Container maxWidth={false} sx={{ py: 4 }}>
          {/* Filters + Export Buttons */}
          <Box sx={{ display:'flex', alignItems:'center', gap:2, mb:3 }}>
            <Filters
              filters={filters}
              setFilters={setFilters}
              regionOptions={regionOptions}
              locationOptions={locationOptions}
              monthOptions={monthOptions}
              priorityOptions={priorityOptions}
            />
            <Box sx={{ display:'flex', alignItems:'center', gap:1, flexShrink: 0 }}>
              <Button
                variant="contained" size="small"
                onClick={()=>exportSection(dashRef.current,'Full_Dashboard.pptx')}
              >Export Dashboard PPT</Button>
              <Button
                variant="outlined" size="small"
                onClick={()=>exportSection(cardsRef.current,'Cards_Slide.pptx')}
              >Export Cards</Button>
              <Button
                variant="outlined" size="small"
                onClick={()=>exportSection(chartsRef.current,'Charts_Slide.pptx')}
              >Export Charts</Button>
            </Box>
          </Box>

          {/* Cards */}
          <Box ref={cardsRef} sx={{ mb: 4 }}>
            <AlarmCard
              summary={filteredSummary}
              rawAlarms={filtered}
              filters={filters}
            />
          </Box>

          {/* Charts */}
          <Box ref={chartsRef} sx={{ mb: 4 }}>
            <SummaryCards
              summary={filteredSummary}
              filters={filters}
              rawAlarms={filtered}
            />
          </Box>
        </Container>
      </Box>
    </ThemeProvider>
  );
}







// src/pages/Dashboard.js
import React, { useEffect, useState, useMemo, useRef, useCallback } from 'react';
import {
  Box, Typography, Container, Button,
  IconButton, createTheme, ThemeProvider, CssBaseline
} from '@mui/material';
import DashboardIcon from '@mui/icons-material/Dashboard';
import Brightness4Icon from '@mui/icons-material/Brightness4';
import Brightness7Icon from '@mui/icons-material/Brightness7';
import Filters from '../components/Filters';
import AlarmCard from '../components/AlarmCard';
import SummaryCards from '../components/SummaryCards';
import { getAlarmSummary, getRawAlarms } from '../services/api';
import { Link } from 'react-router-dom';
import html2canvas from 'html2canvas';
const PptxGenJS = require('pptxgenjs');

// ... [keep all your helpers and imports unchanged]

export default function Dashboard() {
  // theme mode state
  const [mode, setMode] = useState('light');

  // create a theme that overrides background/text for dark mode
  const theme = useMemo(() =>
    createTheme({
      palette: {
        mode,
        ...(mode === 'dark'
          ? {
              background: {
                default: '#121212',
                paper:   '#1e1e1e'
              },
              text: {
                primary:   '#ffffff',
                secondary: '#bbbbbb'
              }
            }
          : {
              background: {
                default: '#fafafa',
                paper:   '#ffffff'
              },
              text: {
                primary:   '#000000',
                secondary: '#333333'
              }
            }
        )
      },
      components: {
        MuiLink: {
          styleOverrides: {
            root: { textDecoration: 'none', color: 'inherit' }
          }
        }
      }
    }),
  [mode]);

  const toggleTheme = useCallback(() => {
    setMode(prev => (prev === 'light' ? 'dark' : 'light'));
  }, []);

  // ... [all of your existing state, effects, memoized filters, export logic, etc. remain exactly the same]

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Box sx={{ width: '100vw', minHeight: '100vh', overflowX: 'hidden' }} ref={dashRef}>
        {/* Header */}
        <Box component="header" sx={{
          display: 'flex', alignItems: 'center', justifyContent: 'space-between',
          borderBottom: 1, borderColor: 'divider', bgcolor: 'background.paper', p: 2
        }}>
          <Box sx={{ display:'flex', alignItems:'center', gap:1 }}>
            <DashboardIcon fontSize="large"/>
            <Typography variant="h4">Alarm Analysis Dashboard</Typography>
          </Box>
          <Box sx={{ display:'flex', alignItems: 'center', gap:2 }}>
            <Link to="/">➤ Dashboard</Link>
            <Link to="/alarms">➤ Raw Alarms</Link>
          </Box>
          <IconButton onClick={toggleTheme} sx={{ ml: 1 }}>
            {mode === 'dark' ? <Brightness7Icon/> : <Brightness4Icon/>}
          </IconButton>
        </Box>

        {/* ... rest of your JSX exactly as before ... */}

      </Box>
    </ThemeProvider>
  );
}



// src/pages/Dashboard.js
import React, { useEffect, useState, useMemo, useRef, useCallback } from 'react';
import {
  Box, Typography, Container, Button,
  IconButton, createTheme, ThemeProvider, CssBaseline
} from '@mui/material';
import DashboardIcon from '@mui/icons-material/Dashboard';
import Brightness4Icon from '@mui/icons-material/Brightness4';
import Brightness7Icon from '@mui/icons-material/Brightness7';
import Filters from '../components/Filters';
import AlarmCard from '../components/AlarmCard';
import SummaryCards from '../components/SummaryCards';
import { getAlarmSummary, getRawAlarms } from '../services/api';
import { Link } from 'react-router-dom';
import html2canvas from 'html2canvas';
const PptxGenJS = require('pptxgenjs');

// helper: convert "01-Apr-25" → "2025-04-01"
function toISODate(apiDate) {
  const [d, monAbbr, yy] = apiDate.split('-');
  const monthNames = {
    Jan: '01', Feb: '02', Mar: '03', Apr: '04',
    May: '05', Jun: '06', Jul: '07', Aug: '08',
    Sep: '09', Oct: '10', Nov: '11', Dec: '12'
  };
  const mm = monthNames[monAbbr] || '01';
  const yyyy = `20${yy}`;
  return `${yyyy}-${mm}-${d.padStart(2, '0')}`;
}

// helper: format month/year for dropdown (e.g. "Apr 25")
function formatMonthYear(apiDate) {
  const [d, monAbbr, yy] = apiDate.split('-');
  return `${monAbbr} ${yy}`;
}

export default function Dashboard() {
  // theme mode state
  const [mode, setMode] = useState('light');
  const theme = useMemo(() =>
    createTheme({
      palette: { mode },
      components: {
        MuiLink: {
          styleOverrides: {
            root: { textDecoration: 'none', color: 'inherit' }
          }
        }
      }
    }),
  [mode]);

  const toggleTheme = useCallback(() => {
    setMode(prev => (prev === 'light' ? 'dark' : 'light'));
  }, []);

  const [summary, setSummary]     = useState(null);
  const [rawAlarms, setRawAlarms] = useState([]);
  const [filters, setFilters]     = useState({
    region: '', location: '', month: '', date: '', priority: ''
  });

  const dashRef   = useRef();
  const cardsRef  = useRef();
  const chartsRef = useRef();

  useEffect(() => {
    Promise.all([getAlarmSummary(), getRawAlarms()])
      .then(([sumRes, rawRes]) => {
        setSummary(sumRes.data);
        setRawAlarms(rawRes.data);
      })
      .catch(console.error);
  }, []);

  // 1️⃣ dropdown options
  const regionOptions = useMemo(
    () => summary ? Object.keys(summary.regionWise) : [],
    [summary]
  );
  const locationOptions = useMemo(
    () => filters.region
      ? Array.from(new Set(
          rawAlarms.filter(a => a.Region === filters.region).map(a => a.Location)
        ))
      : [],
    [rawAlarms, filters.region]
  );
  const monthOptions = useMemo(() => {
    const all = rawAlarms
      .filter(a =>
        (!filters.region   || a.Region   === filters.region) &&
        (!filters.location || a.Location === filters.location)
      )
      .map(a => formatMonthYear(a.Date));
    return Array.from(new Set(all))
      .sort((a, b) => {
        const [mA, yA] = a.split(' ');
        const [mB, yB] = b.split(' ');
        const dateA = new Date(`20${yA}-${mA}-01`);
        const dateB = new Date(`20${yB}-${mB}-01`);
        return dateA - dateB;
      });
  }, [rawAlarms, filters.region, filters.location]);

  const priorityOptions = useMemo(
    () => Array.from(new Set(rawAlarms.map(a => a['CCURE Incident Priority']))),
    [rawAlarms]
  );

  // 2️⃣ filtered base
  const filtered = useMemo(() => (
    rawAlarms.filter(a => {
      if (filters.region   && a.Region   !== filters.region)              return false;
      if (filters.location && a.Location !== filters.location)            return false;
      if (filters.month    && formatMonthYear(a.Date) !== filters.month)  return false;
      if (filters.date     && toISODate(a.Date) !== filters.date)         return false;
      if (filters.priority && a['CCURE Incident Priority'] !== filters.priority) return false;
      return true;
    })
  ), [rawAlarms, filters]);

  // 3️⃣ filteredSummary for cards
  const filteredSummary = useMemo(() => {
    if (!summary) return null;
    const fs = { ...summary };

    if (filters.region) {
      fs.regionWise   = { [filters.region]: summary.regionWise[filters.region] };
      fs.locationWise = {};
      locationOptions
        .filter(l => !filters.location || l === filters.location)
        .forEach(l => {
          fs.locationWise[l] = summary.locationWise[l];
        });
    }

    if (filters.month) {
      const mCount = filtered.filter(a => formatMonthYear(a.Date) === filters.month).length;
      fs.monthWise = { [filters.month]: { count: mCount } };
    } else {
      fs.monthWise = {};
    }

    const opCounts = filtered.reduce((c, a) => {
      const op = a['Name of Person Attending Alarms (First, Last Name)'] || 'Unknown';
      c[op] = (c[op] || 0) + 1;
      return c;
    }, {});
    fs.operatorWise = Object.fromEntries(
      Object.entries(opCounts).map(([k, v]) => [k, { count: v }])
    );

    return fs;
  }, [summary, filtered, filters, locationOptions]);

  if (!summary) return <Typography>Loading dashboard…</Typography>;

  // COMMON export logic
  const exportSection = async (element, fileName = 'Full_Dashboard.pptx') => {
    const canvas = await html2canvas(element);
    const imgData = canvas.toDataURL('image/png');
    const ppt = new PptxGenJS();
    const slide = ppt.addSlide();
    slide.addImage({ data: imgData, x: 0, y: 0, w: '100%', h: '100%' });
    await ppt.writeFile({ fileName });
  };

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Box sx={{ width: '100vw', minHeight: '100vh', overflowX: 'hidden' }} ref={dashRef}>
        {/* Header */}
        <Box component="header" sx={{
          display: 'flex', alignItems: 'center', justifyContent: 'space-between',
          borderBottom: 1, borderColor: 'divider', bgcolor: 'background.paper', p: 2
        }}>
          <Box sx={{ display:'flex', alignItems:'center', gap:1 }}>
            <DashboardIcon fontSize="large"/>
            <Typography variant="h4">Alarm Analysis Dashboard</Typography>
          </Box>
          <Box sx={{ display:'flex', alignItems: 'center', gap:2 }}>
            <Link to="/">➤ Dashboard</Link>
            <Link to="/alarms">➤ Raw Alarms</Link>
          </Box>
          <IconButton onClick={toggleTheme} sx={{ ml: 1 }}>
            {mode === 'dark' ? <Brightness7Icon/> : <Brightness4Icon/>}
          </IconButton>
        </Box>

        <Container maxWidth={false} sx={{ py:4 }}>
          {/* Filters + Inline Export Buttons */}
          <Box sx={{
            display: 'flex',
            alignItems: 'center',
            gap: 2,
            mb: 3
          }}>
            <Filters
              filters={filters} setFilters={setFilters}
              regionOptions={regionOptions}
              locationOptions={locationOptions}
              monthOptions={monthOptions}
              priorityOptions={priorityOptions}
            />
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, flexShrink: 0 }}>
              <Button
                variant="contained" size="small"
                onClick={() => exportSection(dashRef.current, 'Full_Dashboard.pptx')}
              >
                Export Dashboard PPT
              </Button>
              <Button
                variant="outlined" size="small"
                onClick={() => exportSection(cardsRef.current, 'Cards_Slide.pptx')}
              >
                Export Cards
              </Button>
              <Button
                variant="outlined" size="small"
                onClick={() => exportSection(chartsRef.current, 'Charts_Slide.pptx')}
              >
                Export Charts
              </Button>
            </Box>
          </Box>

          {/* Cards */}
          <Box ref={cardsRef} sx={{ mb: 4 }}>
            <AlarmCard
              summary={filteredSummary}
              rawAlarms={filtered}
              filters={filters}
            />
          </Box>

          {/* Charts */}
          <Box ref={chartsRef} sx={{ mb: 4 }}>
            <SummaryCards
              summary={filteredSummary}
              filters={filters}
              rawAlarms={filtered}
            />
          </Box>
        </Container>
      </Box>
    </ThemeProvider>
  );
}









Now read all File Carefully and I want to make changes on my Dashboard.Make Light & Dark mode theme on my Dashboard
Update Needev Below file and give me Updated js file carefully.Dont make another Changes on my file .
make 

File 1

// src/components/AlarmCard.js
import React from 'react';
import { Card, CardContent, Typography, Grid } from '@mui/material';

export default function AlarmCard({ summary, rawAlarms, filters }) {
  if (!summary) return null;

  // helper: turn "01-Apr-25" → "Apr 25"
  const formatMonthYear = dateStr => {
    const [ , mon, yy ] = dateStr.split('-');
    return `${mon} ${yy}`;
  };

  // 1) apply all filters (region, location, month, priority)
  const filtered = rawAlarms.filter(a => {
    if (filters.region   && a.Region   !== filters.region)                         return false;
    if (filters.location && a.Location !== filters.location)                       return false;
    if (filters.month    && formatMonthYear(a.Date) !== filters.month)             return false;
    if (filters.priority && a['CCURE Incident Priority'] !== filters.priority)     return false;
    return true;
  });

  const totalAlarms = filtered.length;

  // normalize helper
  const normalize = str => (str || '').toString().trim().toLowerCase();

  // 2) counts per your rules
  const responseSentCount = filtered.filter(a =>
    normalize(a['If Reoccured Yes/No']) === 'no' &&
    normalize(a['Action Taken']) === 'response sent'
  ).length;

  const notSentCount = filtered.filter(a =>
    normalize(a['If Reoccured Yes/No']) === 'no' &&
    normalize(a['Action Taken']) === 'not sent'
  ).length;

  const reoccurredCount = filtered.filter(a =>
    normalize(a['If Reoccured Yes/No']) === 'yes' &&
    normalize(a['Action Taken']) === 'reoccured'
  ).length;

  const responseSentPercentage = totalAlarms
    ? `${((responseSentCount / totalAlarms) * 100).toFixed(2)}%`
    : '0%';

  return (
    <Grid container spacing={1} sx={{ mb: 2 }}>
      {/* Total Alarms */}
      <Grid item xs={3} sm={1} md={1.5}>
        <Card><CardContent>
          <Typography variant="subtitle1">Total Alarms</Typography>
          <Typography variant="h4">{totalAlarms}</Typography>
        </CardContent></Card>
      </Grid>

      {/* Response Sent */}
      <Grid item xs={3} sm={1} md={1.5}>
        <Card><CardContent>
          <Typography variant="subtitle1">Response Sent</Typography>
          <Typography variant="h4">{responseSentCount}</Typography>
        </CardContent></Card>
      </Grid>

      {/* Not Sent */}
      <Grid item xs={3} sm={1} md={1.5}>
        <Card><CardContent>
          <Typography variant="subtitle1">Not Sent</Typography>
          <Typography variant="h4">{notSentCount}</Typography>
        </CardContent></Card>
      </Grid>

      {/* Re-occurred */}
      <Grid item xs={3} sm={1} md={1.5}>
        <Card><CardContent>
          <Typography variant="subtitle1">Re-occurred</Typography>
          <Typography variant="h4">{reoccurredCount}</Typography>
        </CardContent></Card>
      </Grid>

      {/* Response Sent % */}
      <Grid item xs={3} sm={1} md={1.5}>
        <Card><CardContent>
          <Typography variant="subtitle1">Response Sent %</Typography>
          <Typography variant="h4">{responseSentPercentage}</Typography>
        </CardContent></Card>
      </Grid>
    </Grid>
  );
}


File 2


// src/components/Chart.js
import React, { useEffect, useRef } from 'react';
import Chart from 'chart.js/auto';
import ChartDataLabels from 'chartjs-plugin-datalabels';

// register the datalabels plugin
Chart.register(ChartDataLabels);

// custom multicolor-line plugin
Chart.register({
  id: 'multicolorLine',
  beforeDatasetsDraw(chart) {
    const { ctx, data, config } = chart;
    data.datasets.forEach((dataset, dsIndex) => {
      if (
        config.type === 'line' &&
        Array.isArray(dataset.borderColor) &&
        chart.getDatasetMeta(dsIndex).dataset.options.tension !== undefined
      ) {
        const meta = chart.getDatasetMeta(dsIndex);
        const points = meta.data;
        const colors = dataset.borderColor;

        // hide the default line
        meta.dataset.options.borderColor = 'transparent';

        for (let i = 1; i < points.length; i++) {
          const prev = points[i - 1].getProps(['x', 'y'], true);
          const curr = points[i].getProps(['x', 'y'], true);

          ctx.save();
          ctx.beginPath();
          ctx.moveTo(prev.x, prev.y);
          ctx.lineTo(curr.x, curr.y);
          ctx.lineWidth = dataset.borderWidth;
          ctx.strokeStyle = colors[(i - 1) % colors.length];
          ctx.stroke();
          ctx.restore();
        }
      }
    });
  }
});

export default function MyChart({
  type = 'bar',
  data,
  options = {},
  width = '100%',
  height = '100%'
}) {
  const canvasRef = useRef(null);
  const chartRef  = useRef(null);

  useEffect(() => {
    if (!canvasRef.current) return;
    const ctx = canvasRef.current.getContext('2d');
    chartRef.current?.destroy();

    const isLine = type === 'line';

    // normalize into datasets array
    const rawDatasets = Array.isArray(data.datasets)
      ? data.datasets
      : [{
          label: data.label || '',
          data: data.values || [],
          backgroundColor: data.bgColors   || [],
          borderColor:     data.borderColor|| []
        }];

    const datasets = rawDatasets.map(ds => {
      const bgArr     = Array.isArray(ds.backgroundColor) ? ds.backgroundColor : [ds.backgroundColor];
      const strokeArr = Array.isArray(ds.borderColor)     ? ds.borderColor     : [ds.borderColor];

      return {
        ...ds,
        borderWidth: 2,
        borderColor: strokeArr,
        backgroundColor: isLine ? 'transparent' : bgArr,
        pointBackgroundColor: isLine ? bgArr : undefined,
        pointBorderColor:     isLine ? strokeArr : undefined,
        fill: isLine ? false : ds.fill ?? false,
        ...(isLine && { tension: 0.3, pointRadius: 6 }),
        datalabels: {
          display: true,
          formatter: v => v,
          font: { weight: 'bold' },
          backgroundColor: 'rgba(255,255,255,0.8)',
          borderRadius: 4,
          padding: 4,
          anchor: 'end',
          align: 'top',
          clip: false
        }
      };
    });

    chartRef.current = new Chart(ctx, {
      type,
      data: { labels: data.labels, datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: { duration: 800 },
        plugins: {
          legend: { labels: { font: { size: 14 } } },
          datalabels: { clip: false }
        },
        scales: {
          x: { beginAtZero: true, ...(options.scales?.x || {}) },
          y: { beginAtZero: true, ...(options.scales?.y || {}) }
        },
        ...options
      }
    });

    return () => chartRef.current.destroy();
  }, [type, data, options]);

  return (
    <div style={{ width, height, border: '1px solid #ccc', borderRadius: 4, padding: 8 }}>
      <canvas ref={canvasRef} />
    </div>
  );
}



File 3

SummaryCard.css

.summary-container {
    padding: 20px;
  }
  
  .summary-cards {
    margin-bottom: 30px;
  }
  
  .cards {
    display: flex;
    gap: 1rem;
    margin-bottom: 20px;
  }
  
  .card {
    background-color: black;
    padding: 10px 20px;
    border-radius: 5px;
    font-size: 1.2rem;
  }
  
  .charts {
    display: flex;
    flex-wrap: wrap;
    gap: 2rem;
    justify-content: space-around;
  }
  
  .chart {
    width: 300px;
    max-width: 100%;
  }




File 4



// src/components/SummaryCards.js
import React from 'react';
import MyChart from './Chart';
import { Card, CardContent, Typography, Grid,Box  } from '@mui/material';

const PRIORITY_COLORS = {
  High: '#DC3912',
  Medium: '#FF9900',
  Low: '#109618'
};

const defaultColors = [
  '#FF9900','#109618','#FED06A','#DC3912',
  '#990099','#0099C6','#C1D82F','#66AA00',
  '#3366CC','#B82E2E','#316395','#71C9CD'
];

const REJECTION_COLORS = [
  '#006400','#00008B','#8B008B','#FF1493',
  '#00CED1','#2F4F4F','#6f1c03','#ff9a00'
];

const REJECTION_COLOR_MAP = {
  'Wrong Pin':'#49A044','Facility code':'#49A044',
  'Unknown card':'#49A044','Not activated':'#49A044',
  'Site code':'#49A044','Clearance - Access Violation':'#FFDF00',
  'Expired':'#FFDF00','Lost':'#FFDF00',
  'Disabled Badge':'#FFA500','Duress Alarm':'#FFA500',
};

// helper: "01-Apr-25" → "Apr 25"
const formatMonthYear = dateStr => {
  const [ , mon, yy ] = dateStr.split('-');
  return `${mon} ${yy}`;
};

export default function SummaryCards({ summary, filters, rawAlarms }) {
  if (!summary) return null;

  const {
    rejectionTypeWise = {},
    regionWise = {},
    monthWise = {},
    locationWise = {},
    operatorWise = {}
  } = summary;

  // apply filters
  const filtered = rawAlarms.filter(a => {
    if (filters.region   && a.Region   !== filters.region)                         return false;
    if (filters.location && a.Location !== filters.location)                       return false;
    if (filters.month    && formatMonthYear(a.Date) !== filters.month)             return false;
    if (filters.priority && a['CCURE Incident Priority'] !== filters.priority)     return false;
    return true;
  });

  // 1) Rejection Stats
  const rejectionCounts = filtered.reduce((acc, a) => {
    acc[a.Rejection] = (acc[a.Rejection] || 0) + 1;
    return acc;
  }, {});
  const rejectionStats = Object.entries(rejectionCounts)
    .map(([type,count],i) => {
      const pct = filtered.length
        ? `${((count/filtered.length)*100).toFixed(2)}%`
        : '0%';
      return {
        type, count, percentage: pct,
        color: REJECTION_COLOR_MAP[type]
          || REJECTION_COLORS[i % REJECTION_COLORS.length]
      };
    })
    .sort((a,b)=>b.count-a.count);

  // 2) Priority Wise
  const prCounts = filtered.reduce((acc,a)=> {
    const p = a['CCURE Incident Priority'];
    acc[p] = (acc[p]||0)+1;
    return acc;
  }, {});
  const prLabels = Object.keys(prCounts);
  const prValues = prLabels.map(l=>prCounts[l]);
  const prColors = prLabels.map(l=>PRIORITY_COLORS[l]||'#999');

  // 3) Operator Wise (from summary.operatorWise)
  const opLabels = Object.keys(operatorWise);
  const opValues = opLabels.map(l=>operatorWise[l].count||0);
  const opColors = defaultColors.slice(0,opLabels.length);

  // 4) Partition (region or location)
  const partitionObj = !filters.region
    ? Object.fromEntries(Object.entries(regionWise).map(([r,i])=>[r,i.count||0]))
    : filtered.reduce((acc,a)=>{ acc[a.Location]=(acc[a.Location]||0)+1; return acc; }, {});
  const partLabels = Object.keys(partitionObj);
  const partValues = partLabels.map(l=>partitionObj[l]);
  const partColors = defaultColors.slice(0,partLabels.length);

  // 5) Month Wise
  const monthCounts = filtered.reduce((acc,a)=>{
    const key = formatMonthYear(a.Date);
    acc[key]=(acc[key]||0)+1; return acc;
  }, {});
  const monthOrder = Object.keys(monthCounts).sort((a,b)=>{
    // parse back to date to sort
    const [mA,yA] = a.split(' '), [mB,yB] = b.split(' ');
    const dA = new Date(`20${yA}-${mA}-01`);
    const dB = new Date(`20${yB}-${mB}-01`);
    return dA - dB;
  });
  const monthLabels = monthOrder;
  const monthValues = monthLabels.map(m=>monthCounts[m]);
  const monthColors = defaultColors.slice(0,monthLabels.length);

  // 6) Location Wise
  const locCounts = filtered.reduce((acc,a)=>{ acc[a.Location]=(acc[a.Location]||0)+1; return acc; }, {});
  const locLabels = Object.keys(locCounts);
  const locValues = locLabels.map(l=>locCounts[l]);
  const locColors = defaultColors.slice(0,locLabels.length);

  // 7) Priority by Location
  const locations = [...new Set(filtered.map(a=>a.Location))];
  const priorities = ['Low','Medium','High','Critical'];
  const seriesData = priorities.map((prio,i)=>({
    label: prio,
    data: locations.map(loc=>
      filtered.filter(a=>
        a.Location===loc && a['CCURE Incident Priority']===prio
      ).length
    ),
    borderColor: PRIORITY_COLORS[prio]||defaultColors[i%defaultColors.length],
    backgroundColor: 'transparent'
  }));

   return (
    <>
      {/* Rejection Cards */}
      <Grid container spacing={1} sx={{ mb: 2 }}>
        {rejectionStats.map(r => (
          <Grid item xs={3} sm={1} md={1.5} key={r.type}>
            <Card sx={{ border: `2px solid ${r.color}`, bgcolor: r.color, color: '#fff' }}>
              <CardContent>
                <Typography variant="subtitle2">{r.type}</Typography>
                <Typography variant="h6">{r.count}</Typography>
                <Typography variant="body2">{r.percentage}</Typography>
              </CardContent>
            </Card>
          </Grid>
        ))}
      </Grid>

      {/* Partition / Priority / Location */}
      <Grid container spacing={5} sx={{ mb: 4 }}>
        {partLabels.length > 0 && (
          <Grid item xs={12} sm={6} md={4}>
            <Card>
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  {!filters.region ? 'Global Partition' : `${filters.region} → Location`}
                </Typography>
                <Box width="100%" height={550}>
                  <MyChart
                    type="doughnut"
                    data={{ labels: partLabels, values: partValues, bgColors: partColors, borderColor: partColors }}
                    // remove hard-coded width/height props here
                  />
                </Box>
              </CardContent>
            </Card>
          </Grid>
        )}

        {prLabels.length > 0 && (
          <Grid item xs={12} sm={6} md={4}>
            <Card>
              <CardContent>
                <Typography variant="h6" gutterBottom>Priority Wise</Typography>
                <Box width="100%" height={550}>
                  <MyChart
                    type="pie"
                    data={{ labels: prLabels, values: prValues, bgColors: prColors, borderColor: prColors }}
                  />
                </Box>
              </CardContent>
            </Card>
          </Grid>
        )}

        {locLabels.length > 0 && (
          <Grid item xs={12} sm={12} md={4}>
            <Card>
              <CardContent>
                <Typography variant="h6" gutterBottom>Location Wise</Typography>
                <Box width="100%" height={550}>
                  <MyChart
                    type="line"
                    data={{
                      labels: locLabels,
                      values: locValues,
                      bgColors: locColors,         // your exact defaultColors slice
                      borderColor: locColors       // same array here
                    }}
                    options={{
                      scales: {
                        x: { title: { display: true, text: 'Location' } },
                        y: { title: { display: true, text: 'Alarm Count' } },
                      },
                    }}
                  />
                </Box>
              </CardContent>
            </Card>
          </Grid>
        )}
      </Grid>

      {/* P-by-L, Month & Operator in one row */}
      <Grid container spacing={5} sx={{ mb: 4 }}>
        {/* Priority by Location */}
        <Grid item xs={12} sm={6} md={4}>
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>Priority by Location</Typography>
              <Box width="100%" height={550}>
                <MyChart
                  type="line"
                  data={{ labels: locations, datasets: seriesData }}
                  options={{
                    scales: {
                      x: { title: { display: true, text: 'Location' } },
                      y: { title: { display: true, text: 'Alarm Count' } },
                    },
                    plugins: { legend: { position: 'bottom' } },
                  }}
                />
              </Box>
            </CardContent>
          </Card>
        </Grid>

        {/* Month Wise */}
        <Grid item xs={12} sm={6} md={4}>
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>Month Wise</Typography>
              <Box width="100%" height={550}>
              <MyChart
                    type="line"
                    data={{
                      labels: monthLabels,
                      values: monthValues,
                      bgColors: monthColors,       // your exact defaultColors slice
                      borderColor: monthColors     // same array here
                    }}
                    options={{
                      scales: {
                       x: { title: { display: true, text: 'Month' } },
                        y: { title: { display: true, text: 'Alarm Count' } },
                      },
                    }}
                  />
              </Box>
            </CardContent>
          </Card>
        </Grid>

        {/* Operator Wise */}
        <Grid item xs={12} sm={6} md={4}>
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>Operator Wise</Typography>
              <Box width="100%" height={550}>
                <MyChart
                  type="bar"
                  data={{ labels: opLabels, values: opValues, bgColors: opColors, borderColor: opColors }}
                  options={{
                    scales: {
                      x: { title: { display: true, text: 'Operator' } },
                      y: { title: { display: true, text: 'Alarm Count' } },
                    },
                  }}
                />
              </Box>
            </CardContent>
          </Card>
        </Grid>
      </Grid>
    </>
  );
}



File 5



// src/pages/Dashboard.js
import React, { useEffect, useState, useMemo, useRef } from 'react';
import { Box, Typography, Container, Button } from '@mui/material';
import DashboardIcon from '@mui/icons-material/Dashboard';
import Filters from '../components/Filters';
import AlarmCard from '../components/AlarmCard';
import SummaryCards from '../components/SummaryCards';
import { getAlarmSummary, getRawAlarms } from '../services/api';
import { Link } from 'react-router-dom';
import html2canvas from 'html2canvas';
// import PptxGenJS from 'pptxgenjs';
 // Use CommonJS‐style require so we get the right constructor
 const PptxGenJS = require('pptxgenjs');

// helper: convert "01-Apr-25" → "2025-04-01"
function toISODate(apiDate) {
  const [d, monAbbr, yy] = apiDate.split('-');
  const monthNames = {
    Jan: '01', Feb: '02', Mar: '03', Apr: '04',
    May: '05', Jun: '06', Jul: '07', Aug: '08',
    Sep: '09', Oct: '10', Nov: '11', Dec: '12'
  };
  const mm = monthNames[monAbbr] || '01';
  const yyyy = `20${yy}`;
  return `${yyyy}-${mm}-${d.padStart(2, '0')}`;
}

// helper: format month/year for dropdown (e.g. "Apr 25")
function formatMonthYear(apiDate) {
  const [d, monAbbr, yy] = apiDate.split('-');
  return `${monAbbr} ${yy}`;
}

export default function Dashboard() {
  const [summary, setSummary]     = useState(null);
  const [rawAlarms, setRawAlarms] = useState([]);
  const [filters, setFilters]     = useState({
    region: '', location: '', month: '', date: '', priority: ''
  });

  const dashRef   = useRef();
  const cardsRef  = useRef();
  const chartsRef = useRef();

  useEffect(() => {
    Promise.all([getAlarmSummary(), getRawAlarms()])
      .then(([sumRes, rawRes]) => {
        setSummary(sumRes.data);
        setRawAlarms(rawRes.data);
      })
      .catch(console.error);
  }, []);


  // 1️⃣ dropdown options
  const regionOptions = useMemo(
    () => summary ? Object.keys(summary.regionWise) : [],
    [summary]
  );
  const locationOptions = useMemo(
    () => filters.region
      ? Array.from(new Set(
          rawAlarms.filter(a => a.Region === filters.region).map(a => a.Location)
        ))
      : [],
    [rawAlarms, filters.region]
  );
  const monthOptions = useMemo(() => {
    const all = rawAlarms
      .filter(a =>
        (!filters.region   || a.Region   === filters.region) &&
        (!filters.location || a.Location === filters.location)
      )
      .map(a => formatMonthYear(a.Date));
    return Array.from(new Set(all))
      .sort((a, b) => {
        const [mA, yA] = a.split(' ');
        const [mB, yB] = b.split(' ');
        const dateA = new Date(`20${yA}-${mA}-01`);
        const dateB = new Date(`20${yB}-${mB}-01`);
        return dateA - dateB;
      });
  }, [rawAlarms, filters.region, filters.location]);

  const priorityOptions = useMemo(
    () => Array.from(new Set(rawAlarms.map(a => a['CCURE Incident Priority']))),
    [rawAlarms]
  );

  // 2️⃣ filtered base
  const filtered = useMemo(() => (
    rawAlarms.filter(a => {
      if (filters.region   && a.Region   !== filters.region)              return false;
      if (filters.location && a.Location !== filters.location)            return false;
      if (filters.month    && formatMonthYear(a.Date) !== filters.month)  return false;
      if (filters.date     && toISODate(a.Date) !== filters.date)         return false;
      if (filters.priority && a['CCURE Incident Priority'] !== filters.priority) return false;
      return true;
    })
  ), [rawAlarms, filters]);

  // 3️⃣ filteredSummary for cards
  const filteredSummary = useMemo(() => {
    if (!summary) return null;
    const fs = { ...summary };

    if (filters.region) {
      fs.regionWise   = { [filters.region]: summary.regionWise[filters.region] };
      fs.locationWise = {};
      locationOptions
        .filter(l => !filters.location || l === filters.location)
        .forEach(l => {
          fs.locationWise[l] = summary.locationWise[l];
        });
    }

    if (filters.month) {
      const mCount = filtered.filter(a => formatMonthYear(a.Date) === filters.month).length;
      fs.monthWise = { [filters.month]: { count: mCount } };
    } else {
      fs.monthWise = {};
    }

    const opCounts = filtered.reduce((c, a) => {
      const op = a['Name of Person Attending Alarms (First, Last Name)'] || 'Unknown';
      c[op] = (c[op] || 0) + 1;
      return c;
    }, {});
    fs.operatorWise = Object.fromEntries(
      Object.entries(opCounts).map(([k, v]) => [k, { count: v }])
    );

    return fs;
  }, [summary, filtered, filters, locationOptions]);


  if (!summary) return <Typography>Loading dashboard…</Typography>;

 
    // COMMON export logic
    const exportSection = async (element, fileName = 'Full_Dashboard.pptx') => {


      // Instantiate the PPTX generator
    const ppt = new PptxGenJS();
    // Create a new slide
    const slide = ppt.addSlide();
    // Insert our captured image
    slide.addImage({ data: imgData, x: 0, y: 0, w: '100%', h: '100%' });
    // Save to file
    await ppt.writeFile({ fileName });
  };



  return (
    <Box sx={{ width: '100vw', minHeight: '100vh', overflowX: 'hidden' }} ref={dashRef}>
      {/* Header */}
      <Box component="header" sx={{
        display: 'flex', alignItems: 'center', justifyContent: 'space-between',
        borderBottom: '3px solid #1976d2', bgcolor: '#e3f2fd', p:2
      }}>
        <Box sx={{ display:'flex', alignItems:'center', gap:1 }}>
          <DashboardIcon fontSize="large"/>
          <Typography variant="h4">Alarm Analysis Dashboard</Typography>
        </Box>
        <Box sx={{ display:'flex', gap:2 }}>
          <Link to="/">➤ Dashboard</Link>
          <Link to="/alarms">➤ Raw Alarms</Link>
        </Box>
      </Box>

      <Container maxWidth={false} sx={{ py:4 }}>
        {/* Filters + Inline Export Buttons */}
        <Box sx={{
          display: 'flex',
          alignItems: 'center',
          gap: 2,
          mb: 3
        }}>
          <Filters
            filters={filters} setFilters={setFilters}
            regionOptions={regionOptions}
            locationOptions={locationOptions}
            monthOptions={monthOptions}
            priorityOptions={priorityOptions}
          />
          {/* force no wrap so buttons hug the Priority dropdown */}
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, flexShrink: 0 }}>
            <Button
              variant="contained" size="small"
              onClick={() => exportSection(dashRef.current, 'Full_Dashboard.pptx')}
            >
              Export Dashboard PPT
            </Button>
            <Button
              variant="outlined" size="small"
              onClick={() => exportSection(cardsRef.current, 'Cards_Slide.pptx')}
            >
              Export Cards
            </Button>
            <Button
              variant="outlined" size="small"
              onClick={() => exportSection(chartsRef.current, 'Charts_Slide.pptx')}
            >
              Export Charts
            </Button>
          </Box>
        </Box>

        {/* Cards (no more export button here) */}
        <Box ref={cardsRef} sx={{ mb: 4 }}>
          <AlarmCard
            summary={filteredSummary}
            rawAlarms={filtered}
            filters={filters}
          />
        </Box>

        {/* Charts (no more export button here) */}
        <Box ref={chartsRef} sx={{ mb: 4 }}>
          <SummaryCards
            summary={filteredSummary}
            filters={filters}
            rawAlarms={filtered}
          />
        </Box>
      </Container>
    </Box>
  );
}


