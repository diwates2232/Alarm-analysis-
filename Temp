import React, { useEffect, useRef } from 'react';
import Chart from 'chart.js/auto';

export default function MyChart({
  type = 'bar',
  data,
  options = {},
  width = '100%',
  height = 400
}) {
  const canvasRef = useRef(null);
  const chartRef  = useRef(null);

  useEffect(() => {
    if (!canvasRef.current) return;
    const ctx = canvasRef.current.getContext('2d');
    if (chartRef.current) chartRef.current.destroy();

    // Build datasets: support multi-series if data.datasets provided
    let datasets = [];
    if (Array.isArray(data.datasets)) {
      datasets = data.datasets.map(ds => ({
        label: ds.label,
        data: ds.data,
        backgroundColor: ds.backgroundColor,
        borderColor: ds.borderColor,
        borderWidth: ds.borderWidth ?? 2,
        fill: ds.fill ?? false,
        tension: ds.tension ?? 0.4,
        pointRadius: ds.pointRadius ?? 4
      }));
    } else {
      // single‐series fallback
      datasets = [{
        label: data.label || '',
        data: data.values,
        backgroundColor: data.bgColors,
        borderColor: data.borderColor,
        borderWidth: 2,
        fill: type === 'line' ? false : true,
        tension: type === 'line' ? 0.4 : 0,
        pointRadius: type === 'line' ? 4 : undefined,
      }];
    }

    chartRef.current = new Chart(ctx, {
      type,
      data: {
        labels: data.labels,
        datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        ...options,
      }
    });

    return () => chartRef.current && chartRef.current.destroy();
  }, [type, data, options]);

  return (
    <div style={{ width, height }}>
      <canvas ref={canvasRef} />
    </div>
  );
}






import React from 'react';
import './SummaryCards.css';
import MyChart from './Chart';
import { Card, CardContent, Typography, Grid, Box } from '@mui/material';

// Priority palette
const PRIORITY_COLORS = {
  Low: '#90ee90',
  Medium: '#ffff00',
  High: '#ff0000',
};

export default function SummaryCards({ summary, filters, rawAlarms }) {
  if (!summary) return null;

  // For Location Wise: build a multi-series dataset of Low/Medium/High percentages
  const makeLocationPriorityData = () => {
    const locEntries = Object.entries(summary.locationWise);
    const labels = locEntries.map(([loc]) => loc);
    // For each priority, compute counts & percentages
    const datasets = ['Low', 'Medium', 'High'].map(priority => {
      const data = locEntries.map(([loc, info]) => {
        const total = info.count;
        const count = rawAlarms.filter(a =>
          a.Location === loc && a['CCURE Incident Priority'] === priority
        ).length;
        // percentage
        return total ? (count / total) * 100 : 0;
      });
      return {
        label: `${priority}`,
        data,
        borderColor: PRIORITY_COLORS[priority],
        backgroundColor: PRIORITY_COLORS[priority].replace(')', ',0.2)'),
        fill: false,
        tension: 0.4,
        pointRadius: 4
      };
    });
    return { labels, datasets };
  };

  // Standard single-series helper (unused now but here if needed)
  const makeData = (key, obj) => {
    const labels = Object.keys(obj);
    const values = labels.map(lbl => obj[lbl].count);
    const bg     = labels.map((_, i) => PRIORITY_COLORS[labels[i]] || '#007bff');
    return { labels, values, bgColors: bg, borderColor: bg };
  };

  // Configs: drop standalone priorityWise; replace locationWise
  const configs = [
    {
      key: 'locationWise',
      title: 'Priority Split by Location',
      type: 'line',
      customData: makeLocationPriorityData(),
      options: {
        scales: {
          x: { title: { display: true, text: 'Location' } },
          y: { title: { display: true, text: 'Percentage (%)' } }
        },
        plugins: {
          legend: { position: 'top' }
        }
      },
      fullWidth: true
    }
  ];

  return (
    <Grid container spacing={2}>
      {configs.map(({ key, title, type, customData, options, fullWidth }) => (
        <Grid item xs={12} md={fullWidth ? 12 : 4} key={key}>
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                {title}
              </Typography>

              {/* Legend for line colors */}
              <Box sx={{ display: 'flex', mb: 1 }}>
                {customData.datasets.map(ds => (
                  <Box key={ds.label} sx={{ mr: 3, display: 'flex', alignItems: 'center' }}>
                    <Box sx={{
                      width: 12, height: 12,
                      backgroundColor: ds.borderColor,
                      borderRadius: '50%', mr: 0.5
                    }} />
                    <Typography variant="body2">{ds.label}</Typography>
                  </Box>
                ))}
              </Box>

              <MyChart
                type={type}
                data={customData}
                options={options}
                height={320}
              />
            </CardContent>
          </Card>
        </Grid>
      ))}
    </Grid>
  );
}













Now combine Priority Wise chart & Location Wise chart 
there is no need to Display Both chart.
make a Location Wise Chart big.
Where Display Location Wise how Many Priority Wise Alarms Occured in percentage. add 3 line
for display Prority like low mediun , High , also Display Count .
read below files Carefully and give me Updated js Files.




Now update Location Wise chart ...
use Line chart for Location wise.
At the top display Which Colour are use for Which location Adjust X & Y Axis for count and date or month 
Read below file carefully and update file as per my request.

File 1 Charts.js

import React, { useEffect, useRef } from 'react';
import Chart from 'chart.js/auto';

export default function MyChart({
  type = 'bar',
  data,
  options = {},
  width = '100%',
  height = 400
}) {
  const canvasRef = useRef(null);
  const chartRef  = useRef(null);

  useEffect(() => {
    if (!canvasRef.current) return;
    const ctx = canvasRef.current.getContext('2d');
    if (chartRef.current) chartRef.current.destroy();

    // Build dataset with line-chart specifics if needed
    const ds = {
      label: data.label || '',
      data: data.values,
      backgroundColor: data.bgColors,
      borderColor: data.borderColor,
      borderWidth: 2,
      fill: type === 'line' ? false : true,
      tension: type === 'line' ? 0.4 : 0,
      pointBackgroundColor: data.borderColor,
      pointRadius: type === 'line' ? 4 : undefined,
    };

    chartRef.current = new Chart(ctx, {
      type,
      data: {
        labels: data.labels,
        datasets: [ds],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        ...options,
      }
    });

    return () => chartRef.current && chartRef.current.destroy();
  }, [type, data, options]);

  return (
    <div style={{ width, height }}>
      <canvas ref={canvasRef} />
    </div>
  );
}



File 2

SummaryCards.js


// src/components/SummaryCards.js
import React from 'react';
import './SummaryCards.css';
import MyChart from './Chart';
import { Card, CardContent, Typography, Grid, Box } from '@mui/material';

// Default palette (for non-priority, non-month, non-location)
const DEFAULT_COLORS = [
  '#007bff', '#28a745', '#ffc107',
  '#dc3545', '#6f42c1', '#17a2b8',
  '#fd7e14', '#20c997', '#6c757d',
  '#6610f2',
];

// Priority palette
const PRIORITY_COLORS = {
  Low: '#90ee90',
  Medium: '#ffff00',
  High: '#ff0000',
};

export default function SummaryCards({ summary, filters }) {
  if (!summary) return null;

  // Build data for any key
  const makeData = (key, obj) => {
    let labels = Object.keys(obj);

    // Sort months chronologically
    if (key === 'monthWise') {
      labels = labels.sort((a,b) => {
        const [mA,yA]=a.split('-').map(Number),
              [mB,yB]=b.split('-').map(Number);
        return new Date(yA,mA-1) - new Date(yB,mB-1);
      });
    }

    const values = labels.map(lbl => obj[lbl].count);

    let bg, borderColor;
    if (key === 'priorityWise') {
      bg = labels.map(lbl => PRIORITY_COLORS[lbl] || '#ccc');
      borderColor = bg;
    } else if (key === 'monthWise') {
      bg = labels.map(() => 'rgba(0,123,255,0.2)');
      borderColor = '#007bff';
    } else if (key === 'locationWise') {
      // one colour per location
      bg = labels.map((_,i) => DEFAULT_COLORS[i % DEFAULT_COLORS.length]);
      borderColor = bg;
    } else {
      bg = labels.map((_,i) => DEFAULT_COLORS[i % DEFAULT_COLORS.length]);
      borderColor = bg;
    }

    return { labels, values, bgColors: bg, borderColor };
  };

  // Partition data
  const partitionObj = filters.region
    ? { [filters.region]: summary.regionWise[filters.region] }
    : summary.regionWise;

  // Chart configs
  const configs = [
    { key: 'partition',        title: !filters.region ? 'Global Partition' : `${filters.region} Partition`, type: 'doughnut', dataObj: partitionObj },
    { key: 'priorityWise',     title: 'Priority Wise',      type: 'pie',      dataObj: summary.priorityWise },
    { key: 'rejectionTypeWise',title: 'Rejection Type Wise', type: 'pie',      dataObj: summary.rejectionTypeWise },
    { key: 'operatorWise',     title: 'Operator Wise',      type: 'bar',      dataObj: summary.operatorWise },
    { key: 'monthWise',        title: 'Month Wise',         type: 'line',     dataObj: summary.monthWise },
    filters.region && { key: 'locationWise', title: 'Location Wise', type: 'line', dataObj: summary.locationWise }
  ].filter(Boolean);

  return (
    <Grid container spacing={2}>
      {configs.map(({ key, title, type, dataObj }) => {
        if (!dataObj || Object.keys(dataObj).length === 0) return null;

        const { labels, values, bgColors, borderColor } = makeData(key, dataObj);

        // Custom options for line charts
        const options = (key === 'monthWise' || key === 'locationWise') ? {
          scales: {
            x: { title: { display: true, text: key === 'monthWise' ? 'Month' : 'Location' } },
            y: { title: { display: true, text: 'Alarm Count' } }
          }
        } : {};

        return (
          <Grid item xs={12} md={4} key={key}>
            <Card>
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  {title}
                </Typography>

                {/* Legend for locationWise */}
                {key === 'locationWise' && (
                  <Box sx={{ display: 'flex', flexWrap: 'wrap', mb: 1 }}>
                    {labels.map((loc, i) => (
                      <Box key={loc} sx={{ display: 'flex', alignItems: 'center', mr: 2, mb: 1 }}>
                        <Box sx={{
                          width: 12, height: 12,
                          backgroundColor: bgColors[i],
                          borderRadius: '50%', mr: 0.5
                        }} />
                        <Typography variant="body2">{loc}</Typography>
                      </Box>
                    ))}
                  </Box>
                )}

                <MyChart
                  type={type}
                  data={{ labels, values, bgColors, borderColor }}
                  options={options}
                  height={260}
                />
              </CardContent>
            </Card>
          </Grid>
        );
      })}
    </Grid>
  );
}



Dashboard.js


// src/pages/Dashboard.js
import React, { useEffect, useState, useMemo, useRef } from 'react';
import { Container, Typography } from '@mui/material';
import Filters      from '../components/Filters';
import SummaryCards from '../components/SummaryCards';
import AlarmCard    from '../components/AlarmCard';
import { getAlarmSummary, getRawAlarms } from '../services/api';

export default function Dashboard() {
  const [summary, setSummary]     = useState(null);
  const [rawAlarms, setRawAlarms] = useState([]);
  const [filters, setFilters]     = useState({ region: '', location: '' });

  // 1) Fetch data once
  useEffect(() => {
    Promise.all([ getAlarmSummary(), getRawAlarms() ])
      .then(([sumRes, rawRes]) => {
        setSummary(sumRes.data);
        setRawAlarms(rawRes.data);
      })
      .catch(console.error);
  }, []);

  // 2) Memoize regionOptions so it only changes when summary changes
  const regionOptions = useMemo(() => {
    return summary ? Object.keys(summary.regionWise) : [];
  }, [summary]);

  // 3) Build a map of region → [locations], memoized on rawAlarms and regionOptions
  const regionLocationsMap = useMemo(() => {
    const map = {};
    regionOptions.forEach(region => {
      map[region] = Array.from(
        new Set(
          rawAlarms
            .filter(a => a.Region === region)
            .map(a => a.Location)
        )
      );
    });
    return map;
  }, [rawAlarms, regionOptions]);

  // 4) Build and start slideshow as soon as summary is available
  const slidesRef = useRef([]);
  const slideIdx  = useRef(0);

  useEffect(() => {
    if (!summary) return;   // wait for data
     

    const slides = [{ region: '', location: '' }];
       regionOptions.forEach(region => {
         slides.push({ region, location: '' });
       });

    slidesRef.current = slides;
    slideIdx.current = 0;

    // Immediately show “Global”
    setFilters(slides[0]);

    // Every 60s, advance to the next slide
    const intervalId = setInterval(() => {
      slideIdx.current = (slideIdx.current + 1) % slidesRef.current.length;
      setFilters(slidesRef.current[slideIdx.current]);
    }, 30_000);

    return () => clearInterval(intervalId);
  }, [summary, regionOptions, regionLocationsMap]);

  // 5) Compute filteredSummary exactly as before
  const filteredSummary = useMemo(() => {
    if (!summary) return null;
    const fs = { ...summary };
    if (filters.region) {
      fs.regionWise   = { [filters.region]: summary.regionWise[filters.region] };
      fs.locationWise = {};
      (regionLocationsMap[filters.region] || [])
        .filter(loc => !filters.location || loc === filters.location)
        .forEach(loc => {
          fs.locationWise[loc] = summary.locationWise[loc];
        });
    }
    return fs;
  }, [summary, filters, regionLocationsMap]);

  // 6) Render
  if (!summary) {
    return <Typography>Loading dashboard…</Typography>;
  }

  return (
    <Container sx={{ py: 4 }}>
      <Typography variant="h4" gutterBottom>
        Alarm Analysis Dashboard
      </Typography>

      <Filters
        filters={filters}
        setFilters={setFilters}
        regionOptions={regionOptions}
        locationOptions={filters.region ? regionLocationsMap[filters.region] : []}
      />

      <AlarmCard summary={summary} />

      <SummaryCards
        summary={filteredSummary}
        filters={filters}
      />
    </Container>
  );
}








