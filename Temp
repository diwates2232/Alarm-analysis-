// src/components/Chart.js
import React, { useEffect, useRef } from 'react';
import Chart from 'chart.js/auto';
import ChartDataLabels from 'chartjs-plugin-datalabels';

// register the plugin globally
Chart.register(ChartDataLabels);

const defaultColors = [
  '#3366CC', '#DC3912', '#FF9900', '#109618',
  '#990099', '#0099C6', '#DD4477', '#66AA00',
  '#B82E2E', '#316395'
];

export default function MyChart({
  type = 'bar',
  data,
  options = {},
  width = '100%',
  height = '100%'
}) {
  const canvasRef = useRef(null);
  const chartRef  = useRef(null);

  useEffect(() => {
    if (!canvasRef.current) return;
    const ctx = canvasRef.current.getContext('2d');
    chartRef.current?.destroy();

    // build datasets
    const datasets = Array.isArray(data.datasets)
      ? data.datasets.map(ds => ({
          ...ds,
          borderWidth: 2,
          fill: ds.fill ?? false
        }))
      : [{
          label: data.label || '',
          data: data.values,
          backgroundColor: data.bgColors || defaultColors.slice(0, data.values.length),
          borderColor: data.borderColor || (data.bgColors || defaultColors).slice(0, data.values.length),
          borderWidth: 2,
          ...(type === 'line' && { tension: 0.3, pointRadius: 6 })
        }];

    chartRef.current = new Chart(ctx, {
      type,
      data: {
        labels: data.labels,
        datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: { duration: 800 },
        plugins: {
          legend: {
            display: true,
            labels: { font: { size: 14 } }
          },
          datalabels: {
            anchor: type === 'bar' ? 'end' : 'center',
            align: type === 'bar' ? 'start' : 'end',
            clamp: true,
            clip: true,
            padding: 4,
            borderRadius: 4,
            backgroundColor: 'rgba(0, 0, 0, 0.7)',  // dark semi-transparent box
            color: '#fff',                            // white text
            font: {
              weight: 'bold',
              size: 12
            },
            formatter: (value) => value
          }
        },
        scales: {
          x: { beginAtZero: true, ...(options.scales?.x || {}) },
          y: { beginAtZero: true, ...(options.scales?.y || {}) }
        },
        ...options
      },
      plugins: [ChartDataLabels]
    });

    return () => chartRef.current?.destroy();
  }, [type, data, options]);

  return (
    <div style={{ width, height, border: '1px solid #ccc', borderRadius: 4, padding: 8 }}>
      <canvas ref={canvasRef} />
    </div>
  );
}












// src/components/Chart.js
import React, { useEffect, useRef } from 'react';
import Chart from 'chart.js/auto';
import ChartDataLabels from 'chartjs-plugin-datalabels';

// register the plugin globally
Chart.register(ChartDataLabels);

// stronger, fixed palette
const defaultColors = [
  '#3366CC', '#DC3912', '#FF9900', '#109618',
  '#990099', '#0099C6', '#DD4477', '#66AA00',
  '#B82E2E', '#316395'
];

export default function MyChart({
  type = 'bar',
  data,
  options = {},
  width = '100%',
  height = '100%'
}) {
  const canvasRef = useRef(null);
  const chartRef  = useRef(null);

  useEffect(() => {
    if (!canvasRef.current) return;
    const ctx = canvasRef.current.getContext('2d');

    // destroy existing chart instance
    if (chartRef.current) chartRef.current.destroy();

    // build datasets (single or multi-series)
    const datasets = Array.isArray(data.datasets)
      ? data.datasets.map(ds => ({
          ...ds,
          borderWidth: 2,
          fill: ds.fill ?? false
        }))
      : [{
          label: data.label || '',
          data: data.values,
          backgroundColor: data.bgColors || defaultColors.slice(0, data.values.length),
          borderColor: data.borderColor || (data.bgColors || defaultColors).slice(0, data.values.length),
          borderWidth: 2,
          ...(type === 'line' && { tension: 0.3, pointRadius: 6 })
        }];

    chartRef.current = new Chart(ctx, {
      type,
      data: {
        labels: data.labels,
        datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: { duration: 800 },
        plugins: {
          legend: {
            display: true,
            labels: { font: { size: 14 } }
          },
          datalabels: {
            // try to position inside the bar/point
            anchor: type === 'bar' ? 'end' : 'center',
            align: type === 'bar' ? 'start' : 'end',
            clamp: true,
            clip: true,
            padding: 4,
            font: {
              weight: 'bold',
              size: 12
            },
            color: data.bgColors ? data.bgColors : defaultColors,
            formatter: (value) => value
          }
        },
        scales: {
          x: { beginAtZero: true, ...(options.scales?.x || {}) },
          y: { beginAtZero: true, ...(options.scales?.y || {}) }
        },
        ...options
      },
      plugins: [ChartDataLabels]
    });

    return () => chartRef.current?.destroy();
  }, [type, data, options]);

  return (
    <div style={{ width, height, border: '1px solid #ccc', borderRadius: 4, padding: 8 }}>
      <canvas ref={canvasRef} />
    </div>
  );
}









// src/components/Chart.js
import React, { useEffect, useRef } from 'react';
import Chart from 'chart.js/auto';
import ChartDataLabels from 'chartjs-plugin-datalabels';

// stronger, fixed palette
const defaultColors = [
  '#3366CC', '#DC3912', '#FF9900', '#109618',
  '#990099', '#0099C6', '#DD4477', '#66AA00',
  '#B82E2E', '#316395'
];

export default function MyChart({
  type = 'bar',
  data,
  options = {},
  width = '100%',
  height = '100%'
}) {
  const canvasRef = useRef(null);
  const chartRef  = useRef(null);

  // Register the datalabels plugin once
  useEffect(() => {
    Chart.register(ChartDataLabels);
  }, []);

  useEffect(() => {
    if (!canvasRef.current) return;
    const ctx = canvasRef.current.getContext('2d');
    if (chartRef.current) chartRef.current.destroy();

    let datasets;

    // Multi-series support: if you passed data.datasets array
    if (Array.isArray(data.datasets)) {
      datasets = data.datasets.map(ds => ({
        ...ds,
        borderWidth: 2,
        fill: ds.fill ?? false,
        // enable datalabels on each series
        datalabels: {
          display: true,
          formatter: val => val,
          font: { weight: 'bold' },
          color: '#333'
        }
      }));
    } else {
      // Single-series fallback
      const bg = data.bgColors || defaultColors.slice(0, data.values.length);
      const border = data.borderColor || bg;
      datasets = [{
        label: data.label || '',
        data: data.values,
        backgroundColor: bg,
        borderColor: border,
        borderWidth: 2,
        ...(type === 'line' && { tension: 0.3, pointRadius: 6 }),
        datalabels: {
          display: true,
          formatter: val => val,
          font: { weight: 'bold' },
          color: '#333'
        }
      }];
    }

    chartRef.current = new Chart(ctx, {
      type,
      data: {
        labels: data.labels,
        datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: { duration: 800 },
        plugins: {
          // always show legend
          legend: { labels: { font: { size: 14 } } },
          // datalabels plugin global defaults
          datalabels: {
            anchor: 'end',
            align: 'top'
          }
        },
        scales: {
          x: { beginAtZero: true, ...(options.scales?.x || {}) },
          y: { beginAtZero: true, ...(options.scales?.y || {}) }
        },
        ...options
      }
    });

    return () => chartRef.current?.destroy();
  }, [type, data, options]);

  return (
    <div style={{ width, height, border: '1px solid #ccc', borderRadius: 4, padding: 8 }}>
      <canvas ref={canvasRef} />
    </div>
  );
}














read below Chart.js file carefully and make changes in this file for legends & values and Give me updated js file carefully.
Dont make another changes in this file

File 1

Charts.js



// src/components/Chart.js
import React, { useEffect, useRef } from 'react';
import Chart from 'chart.js/auto';

// stronger, fixed palette
const defaultColors = [
  '#3366CC', '#DC3912', '#FF9900', '#109618',
  '#990099', '#0099C6', '#DD4477', '#66AA00',
  '#B82E2E', '#316395'
];

export default function MyChart({
  type = 'bar',
  data,
  options = {},
  width = '100%',
  height = '100%'
}) {
  const canvasRef = useRef(null);
  const chartRef = useRef(null);

  useEffect(() => {
    if (!canvasRef.current) return;
    const ctx = canvasRef.current.getContext('2d');
    if (chartRef.current) chartRef.current.destroy();

    let datasets;

    // Multi-series support: if you passed data.datasets array
    if (Array.isArray(data.datasets)) {
      datasets = data.datasets.map(ds => ({
        ...ds,
        borderWidth: 2,
        fill: ds.fill ?? false
      }));
    } else {
      // Single-series fallback
      const bg = data.bgColors || defaultColors.slice(0, data.values.length);
      const border = data.borderColor || bg;
      datasets = [{
        label: data.label || '',
        data: data.values,
        backgroundColor: bg,
        borderColor: border,
        borderWidth: 2,
        ...(type === 'line' && { tension: 0.3, pointRadius: 6 })
      }];
    }

    chartRef.current = new Chart(ctx, {
      type,
      data: {
        labels: data.labels,
        datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: { duration: 800 },
        plugins: {
          legend: { labels: { font: { size: 14 } } }
        },
        scales: {
          x: { beginAtZero: true, ...(options.scales?.x || {}) },
          y: { beginAtZero: true, ...(options.scales?.y || {}) }
        },
        ...options
      }
    });

    return () => chartRef.current?.destroy();
  }, [type, data, options]);

  return (
    <div style={{ width, height, border: '1px solid #ccc', borderRadius: 4, padding: 8 }}>
      <canvas ref={canvasRef} />
    </div>
  );
}
