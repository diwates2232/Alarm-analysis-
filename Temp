// src/pages/AlarmAnalysisDashboard.js
import React, { useEffect, useState, useMemo } from 'react';
import {
  Container,
  Typography,
  Button,
  ButtonGroup,
  Box
} from '@mui/material';
import { DataGrid } from '@mui/x-data-grid';
import * as XLSX from 'xlsx';
import { getRawAlarms } from '../services/api';

const AlarmAnalysisDashboard = () => {
  const [alarms, setAlarms] = useState([]);
  const [loading, setLoading] = useState(true);
  const [view, setView] = useState('employee'); // employee | door | detailed

  useEffect(() => {
    getRawAlarms()
      .then(res => setAlarms(res.data || []))
      .catch(err => {
        console.error(err);
        setAlarms([]);
      })
      .finally(() => setLoading(false));
  }, []);

  // 1) Employee Analysis
  const employeeStats = useMemo(() => {
    const stats = {};
    alarms.forEach(a => {
      const emp = a['Employee Name'] || 'Unknown';
      const dt = `${a.Date} ${a['Time of  Alarm (Local time)']}`;
      if (!stats[emp]) {
        stats[emp] = {
          total: 0,
          types: new Set(),
          doorRej: {}, 
          lastDt: dt,
          lastRegion: a.Region,
          lastLocation: a.Location
        };
      }
      const e = stats[emp];
      e.total += 1;
      e.types.add(a.Rejection);
      const drKey = `${a.Door}::${a.Rejection}`;
      e.doorRej[drKey] = (e.doorRej[drKey] || 0) + 1;
      if (dt > e.lastDt) {
        e.lastDt = dt;
        e.lastRegion = a.Region;
        e.lastLocation = a.Location;
      }
    });

    return Object.entries(stats).map(([emp, s], idx) => {
      const repeats = Object.entries(s.doorRej).filter(([,cnt]) => cnt > 1);
      let repeatedDoor = '', repeatCount = 0;
      if (repeats.length) {
        const [key, cnt] = repeats.reduce((a,b)=>a[1]>b[1]?a:b);
        [repeatedDoor] = key.split('::');
        repeatCount = cnt;
      }
      const [lastDate, lastTime] = s.lastDt.split(' ');
      return {
        id: idx,
        employee: emp,
        lastDate,
        lastTime,
        totalAlarms: s.total,
        repeatedDoor,
        repeatCount,
        rejectionTypes: Array.from(s.types).join(', '),
        location: s.lastLocation,
        region: s.lastRegion
      };
    });
  }, [alarms]);

  const empColumns = [
    { field: 'employee', headerName: 'Employee', width: 180 },
    { field: 'lastDate', headerName: 'Last Date', width: 120 },
    { field: 'lastTime', headerName: 'Last Time', width: 120 },
    { field: 'totalAlarms', headerName: 'Total Alarms', width: 130 },
    { field: 'repeatedDoor', headerName: 'Repeated Door', width: 200 },
    { field: 'repeatCount', headerName: 'Repeat Count', width: 130 },
    { field: 'rejectionTypes', headerName: 'Types of Rejection', width: 300 },
    { field: 'location', headerName: 'Location', width: 150 },
    { field: 'region', headerName: 'Region', width: 120 }
  ];

  // 2) Door Details
  const doorStats = useMemo(() => {
    const d = {};
    alarms.forEach(a => {
      const door = a.Door || 'Unknown';
      if (!d[door]) d[door] = { total: 0, rejections: {} };
      d[door].total += 1;
      d[door].rejections[a.Rejection] = (d[door].rejections[a.Rejection] || 0) + 1;
    });
    return Object.entries(d)
      .filter(([,s]) => s.total > 1)
      .map(([door,s], idx) => ({
        id: idx,
        door,
        total: s.total,
        rejectionCounts: Object.entries(s.rejections)
          .map(([type,c]) => `${type}: ${c}`)
          .join(', ')
      }));
  }, [alarms]);

  const doorColumns = [
    { field: 'door', headerName: 'Door', width: 300 },
    { field: 'total', headerName: 'Total Alarms', width: 150 },
    { field: 'rejectionCounts', headerName: 'Rejection Counts', width: 400 }
  ];

  // 3) Detailed Records
  const rawColumns = [
    { field: 'Sr. No', headerName: 'Sr. No', width: 90 },
    { field: 'Date', headerName: 'Date', width: 120 },
    { field: 'Time of  Alarm (Local time)', headerName: 'Time', width: 150 },
    { field: 'Type of Alarm', headerName: 'Type', width: 150 },
    { field: 'Door', headerName: 'Door', width: 250 },
    { field: 'Location', headerName: 'Location', width: 150 },
    { field: 'Region', headerName: 'Region', width: 120 },
    { field: 'Rejection', headerName: 'Rejection', width: 180 },
    { field: 'CCURE Incident Priority', headerName: 'Priority', width: 150 },
    {
      field: 'Name of Person Attending Alarms (First, Last Name)',
      headerName: 'Operator',
      width: 200
    },
    { field: 'Action Taken', headerName: 'Action Taken', width: 150 },
    { field: ' Time Taken (Min)', headerName: 'Time Taken (Min)', width: 150 }
  ];
  const rawRows = useMemo(() => alarms.map((a,i)=>({id:i,...a})), [alarms]);

  const exportToExcel = () => {
    // export whichever view: for simplicity use raw
    const ws = XLSX.utils.json_to_sheet(rawRows);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Alarms');
    XLSX.writeFile(wb, 'alarms.xlsx');
  };

  if (loading) {
    return (
      <Container sx={{mt:4}}>
        <Typography variant="h4">Alarm Analysis</Typography>
        <Typography>Loading…</Typography>
      </Container>
    );
  }

  return (
    <Container sx={{ mt:4, height: '90vh' }}>
      <Typography variant="h4" gutterBottom>
        Alarm Analysis Dashboard
      </Typography>

      <ButtonGroup variant="outlined" sx={{ mb:2 }}>
        <Button
          onClick={()=>setView('employee')}
          variant={view==='employee'?'contained':'outlined'}
        >
          Employee Analysis
        </Button>
        <Button
          onClick={()=>setView('door')}
          variant={view==='door'?'contained':'outlined'}
        >
          Door Details
        </Button>
        <Button
          onClick={()=>setView('detailed')}
          variant={view==='detailed'?'contained':'outlined'}
        >
          Detailed Records
        </Button>
      </ButtonGroup>

      {view === 'employee' && (
        <Box sx={{ height: '80%', width:'100%' }}>
          <DataGrid
            rows={employeeStats}
            columns={empColumns}
            pageSize={10}
            rowsPerPageOptions={[10]}
          />
        </Box>
      )}

      {view === 'door' && (
        <Box sx={{ height: '80%', width:'100%' }}>
          <DataGrid
            rows={doorStats}
            columns={doorColumns}
            pageSize={5}
            rowsPerPageOptions={[5]}
          />
        </Box>
      )}

      {view === 'detailed' && (
        <>
          <Button
            variant="contained"
            color="primary"
            onClick={exportToExcel}
            sx={{ mb:1 }}
          >
            Export Detailed Excel
          </Button>
          <Box sx={{ height: '75%', width:'100%' }}>
            <DataGrid
              rows={rawRows}
              columns={rawColumns}
              pageSize={10}
              rowsPerPageOptions={[10,20,50]}
            />
          </Box>
        </>
      )}
    </Container>
  );
};

export default AlarmAnalysisDashboard;





import AlarmAnalysisDashboard from './pages/AlarmAnalysisDashboard';
// …
<Route path="/alarms" element={<AlarmAnalysisDashboard />} />





Read below API Responce as well Js files Carefully .

File 1

AlarmsTable.js

// src/components/AlarmsTable.js
import React, { useMemo } from 'react';
import { DataGrid } from '@mui/x-data-grid';
import { Button, Typography } from '@mui/material';
import * as XLSX from 'xlsx';

const AlarmsTable = ({ alarms = [] }) => {
  // Excel export
  const exportToExcel = () => {
    const ws = XLSX.utils.json_to_sheet(alarms);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Alarms');
    XLSX.writeFile(wb, 'alarms.xlsx');
  };

  // 1) Aggregate per-employee stats
  const employeeStats = useMemo(() => {
    const stats = {};
    alarms.forEach(a => {
      const emp = a['Employee Name'] || 'Unknown';
      const dt = a.Date + ' ' + a['Time of  Alarm (Local time)'];
      if (!stats[emp]) {
        stats[emp] = {
          total: 0,
          types: new Set(),
          doorRej: {},    // key=door::rej, value=count
          lastDt: dt,
          lastRegion: a.Region,
          lastLocation: a.Location,
        };
      }
      const e = stats[emp];
      e.total += 1;
      e.types.add(a.Rejection);
      const drKey = `${a.Door}::${a.Rejection}`;
      e.doorRej[drKey] = (e.doorRej[drKey] || 0) + 1;
      // track latest
      if (dt > e.lastDt) {
        e.lastDt = dt;
        e.lastRegion = a.Region;
        e.lastLocation = a.Location;
      }
    });

    // Build rows
    return Object.entries(stats).map(([emp, s], idx) => {
      // find door+rej with max repeats
      const repeats = Object.entries(s.doorRej)
        .filter(([,cnt]) => cnt > 1);
      let topDoor = '', topCount = 0;
      if (repeats.length) {
        const [key, cnt] = repeats.reduce((a, b) => a[1] > b[1] ? a : b);
        [topDoor] = key.split('::');
        topCount = cnt;
      }
      const [lastDate, lastTime] = s.lastDt.split(' ');
      return {
        id: idx,
        employee: emp,
        lastDate,
        lastTime,
        total: s.total,
        repeatedDoor: topDoor,
        repeatCount: topCount,
        rejectionTypes: Array.from(s.types).join(', '),
        location: s.lastLocation,
        region: s.lastRegion,
      };
    });
  }, [alarms]);

  // 2) Door Analysis unchanged
  const doorStats = useMemo(() => {
    const d = {};
    alarms.forEach(a => {
      const door = a.Door || 'Unknown';
      if (!d[door]) d[door] = { total: 0, rejections: {} };
      d[door].total += 1;
      d[door].rejections[a.Rejection] = (d[door].rejections[a.Rejection]||0) + 1;
    });
    return Object.entries(d)
      .filter(([, s]) => s.total > 1)
      .map(([door, s], idx) => ({
        id: idx,
        door,
        total: s.total,
        rejectionCounts: Object.entries(s.rejections)
          .map(([type,c]) => `${type}:${c}`)
          .join(', ')
      }));
  }, [alarms]);

  // 3) Detailed raw rows
  const rawRows = useMemo(() => alarms.map((a,i) => ({ id: i, ...a })), [alarms]);

  if (!alarms.length) {
    return (
      <Typography variant="h6" align="center" style={{ marginTop: 40 }}>
        No alarm records to display.
      </Typography>
    );
  }

  // Columns
  const empColumns = [
    { field: 'employee', headerName: 'Employee', width: 180 },
    { field: 'lastDate', headerName: 'Last Date', width: 120 },
    { field: 'lastTime', headerName: 'Last Time', width: 120 },
    { field: 'total', headerName: 'Total Alarms', width: 130 },
    { field: 'repeatedDoor', headerName: 'Repeated Door', width: 200 },
    { field: 'repeatCount', headerName: 'Repeat Count', width: 130 },
    { field: 'rejectionTypes', headerName: 'Types of Rejection', width: 300 },
    { field: 'location', headerName: 'Location', width: 150 },
    { field: 'region', headerName: 'Region', width: 120 },
  ];

  const doorColumns = [
    { field: 'door', headerName: 'Door', width: 300 },
    { field: 'total', headerName: 'Total Alarms', width: 150 },
    { field: 'rejectionCounts', headerName: 'Rejection Counts', width: 400 }
  ];

  const rawColumns = [
    { field: 'Sr. No', headerName: 'Sr. No', width: 90 },
    { field: 'Date', headerName: 'Date', width: 120 },
    { field: 'Time of  Alarm (Local time)', headerName: 'Time', width: 150 },
    { field: 'Type of Alarm', headerName: 'Type', width: 150 },
    { field: 'Door', headerName: 'Door', width: 250 },
    { field: 'Location', headerName: 'Location', width: 150 },
    { field: 'Region', headerName: 'Region', width: 120 },
    { field: 'Rejection', headerName: 'Rejection', width: 180 },
    { field: 'CCURE Incident Priority', headerName: 'Priority', width: 150 },
    {
      field: 'Name of Person Attending Alarms (First, Last Name)',
      headerName: 'Operator',
      width: 200
    },
    { field: 'Action Taken', headerName: 'Action Taken', width: 150 },
    { field: ' Time Taken (Min)', headerName: 'Time Taken (Min)', width: 150 }
  ];

  return (
    <div style={{ width: '100%', height: '100vh' }}>
      {/* Employee Analysis */}
      <Typography variant="h5" gutterBottom>
        Employee Analysis
      </Typography>
      <div style={{ height: '30%', marginBottom: 24 }}>
        <DataGrid
          rows={employeeStats}
          columns={empColumns}
          pageSize={10}
          rowsPerPageOptions={[10]}
          autoHeight={false}
        />
      </div>

      {/* Door Analysis */}
      <Typography variant="h5" gutterBottom>
        Door Analysis
      </Typography>
      <div style={{ height: '20%', marginBottom: 24 }}>
        <DataGrid
          rows={doorStats}
          columns={doorColumns}
          pageSize={5}
          rowsPerPageOptions={[5]}
          autoHeight={false}
        />
      </div>

      {/* Detailed Records */}
      <Typography variant="h5" gutterBottom>
        Detailed Alarm Records
      </Typography>
      <Button
        variant="contained"
        color="primary"
        onClick={exportToExcel}
        style={{ marginBottom: 16 }}
      >
        Export to Excel
      </Button>
      <div style={{ height: '40%' }}>
        <DataGrid
          rows={rawRows}
          columns={rawColumns}
          getRowClassName={params =>
            params.row[' Time Taken (Min)'] > 0 ? 'sla-breach' : ''
          }
          pageSize={10}
          rowsPerPageOptions={[10, 20, 50]}
          autoHeight={false}
        />
      </div>
    </div>
  );
};

export default AlarmsTable;





file 2

rawAlarms.js

import React, { useEffect, useState, useMemo } from 'react';
import AlarmsTable from '../components/AlarmsTable';
import { getRawAlarms } from '../services/api';
import { Typography, Container, Grid, TextField, MenuItem } from '@mui/material';

const RawAlarms = () => {
  const [alarms, setAlarms] = useState([]);
  const [loading, setLoading] = useState(true);

  const [filters, setFilters] = useState({
    region: '',
    location: '',
    employee: '',
    door: '',
    priority: '',
    rejection: ''
  });

  useEffect(() => {
    getRawAlarms()
      .then(res => setAlarms(res.data || []))
      .catch(err => {
        console.error(err);
        setAlarms([]);
      })
      .finally(() => setLoading(false));
  }, []);

  // Filtered by region first
  const regionFiltered = useMemo(() => {
    return filters.region
      ? alarms.filter(a => a.Region === filters.region)
      : alarms;
  }, [alarms, filters.region]);

  // Then by location
  const locationFiltered = useMemo(() => {
    return filters.location
      ? regionFiltered.filter(a => a.Location === filters.location)
      : regionFiltered;
  }, [regionFiltered, filters.location]);

  // Now build options from locationFiltered
  const regionOptions = useMemo(() => [...new Set(alarms.map(a => a.Region))], [alarms]);
  const locationOptions = useMemo(() => [...new Set(regionFiltered.map(a => a.Location))], [regionFiltered]);
  const employeeOptions = useMemo(() => [...new Set(locationFiltered.map(a => a['Employee Name']))], [locationFiltered]);
  const doorOptions = useMemo(() => [...new Set(locationFiltered.map(a => a.Door))], [locationFiltered]);
  const priorityOptions = useMemo(() => [...new Set(locationFiltered.map(a => a['CCURE Incident Priority']))], [locationFiltered]);
  const rejectionOptions = useMemo(() => [...new Set(locationFiltered.map(a => a.Rejection))], [locationFiltered]);

  // Finally apply all filters
  const filteredAlarms = useMemo(() => {
    return alarms.filter(a => {
      if (filters.region && a.Region !== filters.region) return false;
      if (filters.location && a.Location !== filters.location) return false;
      if (filters.employee && a['Employee Name'] !== filters.employee) return false;
      if (filters.door && a.Door !== filters.door) return false;
      if (filters.priority && a['CCURE Incident Priority'] !== filters.priority) return false;
      if (filters.rejection && a.Rejection !== filters.rejection) return false;
      return true;
    });
  }, [alarms, filters]);

  if (loading) {
    return (
      <Container style={{ marginTop: 24 }}>
        <Typography variant="h4">Raw Alarms</Typography>
        <Typography>Loading alarms…</Typography>
      </Container>
    );
  }

  return (
    <Container style={{ marginTop: 24 }}>
      <Typography variant="h4" gutterBottom>
        Raw Alarms
      </Typography>

      <Grid container spacing={2} style={{ marginBottom: 16 }}>
        {[
          { label: 'Region', field: 'region', options: regionOptions },
          { label: 'Location', field: 'location', options: locationOptions },
          { label: 'Employee', field: 'employee', options: employeeOptions },
          { label: 'Door', field: 'door', options: doorOptions },
          { label: 'Priority', field: 'priority', options: priorityOptions },
          { label: 'Rejection', field: 'rejection', options: rejectionOptions },
        ].map(({ label, field, options }) => (
          <Grid item xs={12} sm={6} md={4} lg={2} key={field}>
            <TextField
              select
              label={label}
              fullWidth
              value={filters[field]}
              onChange={e => setFilters(f => ({ ...f, [field]: e.target.value }))}
            >
              <MenuItem value="">All</MenuItem>
              {options.map(opt => (
                <MenuItem key={opt} value={opt}>{opt}</MenuItem>
              ))}
            </TextField>
          </Grid>
        ))}
      </Grid>

      <AlarmsTable alarms={filteredAlarms} />
    </Container>
  );
};

export default RawAlarms;



http://localhost:3000/api/alarms/raw

responce-
[
  {
    "Sr. No": 1,
    "Date": "01-Apr-25",
    "Time of  Alarm (Local time)": "05:21:18",
    "Owner": "GSOC",
    "Type of Alarm": "Badge Access",
    "Door": "EMEA_LT_VNO_GAMA_9th Flr_Main Entrance",
    "Location": "LT.Vilnius",
    "Region": "EMEA",
    "Rejection": "Wrong Pin",
    "CCURE Incident Priority": "Low",
    "Name of Person Attending Alarms (First, Last Name)": "Manisha Choudhari",
    "Employee Name": "Jhorar, Kapil",
    "Employee ID No": 326022,
    "If Reoccured Yes/No": "No",
    "Action Taken": "Not Sent",
    "Remediation Notes": "Email not sent- As currently we are not sending 1st and 2nd time Wrong Pin Access Violation mail to EMEA rigion",
    "Target SLA in Mins": "0:00:00",
    "Date of Action (MM/DD/YY)": "01-Apr-25",
    "Time of Action": "05:21:18",
    " Time Taken (Min)": 0,
    "Time of Completion": "05:21:18",
    "If not resolved, escalated to?": "NA",
    "Date of Escalation": "NA",
    "Time Of Escalation": "NA",
    "Completed By": "Manisha Choudhari"
  },
  {
    "Sr. No": 2,
    "Date": "01-Apr-25",
    "Time of  Alarm (Local time)": "11:12:09",
    "Owner": "GSOC",
    "Type of Alarm": "Badge Access",
    "Door": "EMEA_LT_VNO_GAMA_9th Flr_Main Entrance",
    "Location": "LT.Vilnius",
    "Region": "EMEA",
    "Rejection": "Wrong Pin",
    "CCURE Incident Priority": "Low",
    "Name of Person Attending Alarms (First, Last Name)": "Swapnil Diwate",
    "Employee Name": "Zikov Laurino, Ivan Alexander",
    "If Reoccured Yes/No": "No",
    "Action Taken": "Not Sent",
    "Remediation Notes": "Email not sent- As currently we are not sending 1st and 2nd time Wrong Pin Access Violation mail to EMEA rigion",
    "Target SLA in Mins": "0:00:00",
    "Date of Action (MM/DD/YY)": "01-Apr-25",
    "Time of Action": "11:12:09",
    " Time Taken (Min)": 0,
    "Time of Completion": "11:12:09",
    "If not resolved, escalated to?": "NA",
    "Date of Escalation": "NA",
    "Time Of Escalation": "NA",
    "Completed By": "Swapnil Diwate"
  },



Expected output is 
Make Only One table Alarm Analysis dashboard-
Wrere initailly Display Employee Wise Alarm Analysis table and Add two buttons for see door details and details Alarm records.






