// src/components/SummaryCards.js
import React from 'react';
import MyChart from './Chart';
import { Card, CardContent, Typography, Grid, Box } from '@mui/material';

// … all your constants and helpers unchanged …

export default function SummaryCards({ summary, filters, rawAlarms }) {
  if (!summary) return null;

  // … your data-preparation code unchanged …

  return (
    <>
      {/* Rejection Cards */}
      <Grid container spacing={2} sx={{ mb: 2 }}>
        {rejectionStats.map(r => (
          <Grid item xs={12} sm={6} md={3} key={r.type}>
            <Card sx={{ border: `2px solid ${r.color}`, bgcolor: r.color, color: '#fff' }}>
              <CardContent>
                <Typography variant="subtitle2">{r.type}</Typography>
                <Typography variant="h6">{r.count}</Typography>
                <Typography variant="body2">{r.percentage}</Typography>
              </CardContent>
            </Card>
          </Grid>
        ))}
      </Grid>

      {/* Partition / Priority / Location */}
      <Grid container spacing={5} sx={{ mb: 4 }}>
        {partLabels.length > 0 && (
          <Grid item xs={12} sm={6} md={4}>
            <Card>
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  {!filters.region ? 'Global Partition' : `${filters.region} → Location`}
                </Typography>
                <Box width="100%" height={400}>
                  <MyChart
                    type="doughnut"
                    data={{ labels: partLabels, values: partValues, bgColors: partColors, borderColor: partColors }}
                    // remove hard-coded width/height props here
                  />
                </Box>
              </CardContent>
            </Card>
          </Grid>
        )}

        {prLabels.length > 0 && (
          <Grid item xs={12} sm={6} md={4}>
            <Card>
              <CardContent>
                <Typography variant="h6" gutterBottom>Priority Wise</Typography>
                <Box width="100%" height={400}>
                  <MyChart
                    type="pie"
                    data={{ labels: prLabels, values: prValues, bgColors: prColors, borderColor: prColors }}
                  />
                </Box>
              </CardContent>
            </Card>
          </Grid>
        )}

        {locLabels.length > 0 && (
          <Grid item xs={12} sm={12} md={4}>
            <Card>
              <CardContent>
                <Typography variant="h6" gutterBottom>Location Wise</Typography>
                <Box width="100%" height={400}>
                  <MyChart
                    type="line"
                    data={{ labels: locLabels, values: locValues, bgColors: locColors, borderColor: locColors }}
                    options={{
                      scales: {
                        x: { title: { display: true, text: 'Location' } },
                        y: { title: { display: true, text: 'Alarm Count' } },
                      },
                    }}
                  />
                </Box>
              </CardContent>
            </Card>
          </Grid>
        )}
      </Grid>

      {/* P-by-L, Month & Operator in one row */}
      <Grid container spacing={5} sx={{ mb: 4 }}>
        {/* Priority by Location */}
        <Grid item xs={12} sm={6} md={4}>
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>Priority by Location</Typography>
              <Box width="100%" height={400}>
                <MyChart
                  type="line"
                  data={{ labels: locations, datasets: seriesData }}
                  options={{
                    scales: {
                      x: { title: { display: true, text: 'Location' } },
                      y: { title: { display: true, text: 'Alarm Count' } },
                    },
                    plugins: { legend: { position: 'bottom' } },
                  }}
                />
              </Box>
            </CardContent>
          </Card>
        </Grid>

        {/* Month Wise */}
        <Grid item xs={12} sm={6} md={4}>
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>Month Wise</Typography>
              <Box width="100%" height={400}>
                <MyChart
                  type="line"
                  data={{ labels: monthLabels, values: monthValues, bgColors: monthColors, borderColor: monthColors }}
                  options={{
                    scales: {
                      x: { title: { display: true, text: 'Month' } },
                      y: { title: { display: true, text: 'Alarm Count' } },
                    },
                  }}
                />
              </Box>
            </CardContent>
          </Card>
        </Grid>

        {/* Operator Wise */}
        <Grid item xs={12} sm={6} md={4}>
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>Operator Wise</Typography>
              <Box width="100%" height={400}>
                <MyChart
                  type="bar"
                  data={{ labels: opLabels, values: opValues, bgColors: opColors, borderColor: opColors }}
                  options={{
                    scales: {
                      x: { title: { display: true, text: 'Operator' } },
                      y: { title: { display: true, text: 'Alarm Count' } },
                    },
                  }}
                />
              </Box>
            </CardContent>
          </Card>
        </Grid>
      </Grid>
    </>
  );
}








raed All File Carefully and Solve issue .dont make Another changes in this file

File 1

AlarmCard.js


// src/components/AlarmCard.js
import React from 'react';
import { Card, CardContent, Typography, Grid } from '@mui/material';

export default function AlarmCard({ summary, rawAlarms, filters }) {
  if (!summary) return null;

  // helper: turn "01-Apr-25" → "Apr 25"
  const formatMonthYear = dateStr => {
    const [ , mon, yy ] = dateStr.split('-');
    return `${mon} ${yy}`;
  };

  // 1) apply all filters (region, location, month, priority)
  const filtered = rawAlarms.filter(a => {
    if (filters.region   && a.Region   !== filters.region)                         return false;
    if (filters.location && a.Location !== filters.location)                       return false;
    if (filters.month    && formatMonthYear(a.Date) !== filters.month)             return false;
    if (filters.priority && a['CCURE Incident Priority'] !== filters.priority)     return false;
    return true;
  });

  const totalAlarms = filtered.length;

  // normalize helper
  const normalize = str => (str || '').toString().trim().toLowerCase();

  // 2) counts per your rules
  const responseSentCount = filtered.filter(a =>
    normalize(a['If Reoccured Yes/No']) === 'no' &&
    normalize(a['Action Taken']) === 'response sent'
  ).length;

  const notSentCount = filtered.filter(a =>
    normalize(a['If Reoccured Yes/No']) === 'no' &&
    normalize(a['Action Taken']) === 'not sent'
  ).length;

  const reoccurredCount = filtered.filter(a =>
    normalize(a['If Reoccured Yes/No']) === 'yes' &&
    normalize(a['Action Taken']) === 'reoccured'
  ).length;

  const responseSentPercentage = totalAlarms
    ? `${((responseSentCount / totalAlarms) * 100).toFixed(2)}%`
    : '0%';

  return (
    <Grid container spacing={2} sx={{ mb: 3 }}>
      {/* Total Alarms */}
      <Grid item xs={12} sm={6} md={2}>
        <Card><CardContent>
          <Typography variant="subtitle1">Total Alarms</Typography>
          <Typography variant="h4">{totalAlarms}</Typography>
        </CardContent></Card>
      </Grid>

      {/* Response Sent */}
      <Grid item xs={12} sm={6} md={2}>
        <Card><CardContent>
          <Typography variant="subtitle1">Response Sent</Typography>
          <Typography variant="h4">{responseSentCount}</Typography>
        </CardContent></Card>
      </Grid>

      {/* Not Sent */}
      <Grid item xs={12} sm={6} md={2}>
        <Card><CardContent>
          <Typography variant="subtitle1">Not Sent</Typography>
          <Typography variant="h4">{notSentCount}</Typography>
        </CardContent></Card>
      </Grid>

      {/* Re-occurred */}
      <Grid item xs={12} sm={6} md={2}>
        <Card><CardContent>
          <Typography variant="subtitle1">Re-occurred</Typography>
          <Typography variant="h4">{reoccurredCount}</Typography>
        </CardContent></Card>
      </Grid>

      {/* Response Sent % */}
      <Grid item xs={12} sm={6} md={2}>
        <Card><CardContent>
          <Typography variant="subtitle1">Response Sent %</Typography>
          <Typography variant="h4">{responseSentPercentage}</Typography>
        </CardContent></Card>
      </Grid>
    </Grid>
  );
}


File 2
Alarmtable.js


// src/components/AlarmsTable.js
import React, { useMemo } from 'react';
import { DataGrid } from '@mui/x-data-grid';
import { Button, Typography } from '@mui/material';
import * as XLSX from 'xlsx';

const AlarmsTable = ({
  alarms = [],
  maxRows = 10,
  tableType = 'employee'
}) => {
  // Excel export
  const exportToExcel = () => {
    const ws = XLSX.utils.json_to_sheet(alarms);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Alarms');
    XLSX.writeFile(wb, 'alarms.xlsx');
  };

  // 1) Employee stats with lastAction and ID
  const employeeStats = useMemo(() => {
    const stats = {};
    alarms.forEach(a => {
      const emp = a['Employee Name'] || 'Unknown';
      const empId = a['Employee ID No'] ?? '';
      const dt = a.Date + ' ' + a['Time of  Alarm (Local time)'];
      if (!stats[emp]) {
        stats[emp] = {
          total: 0,
          types: new Set(),
          doorRej: {},
          lastDt: dt,
          lastRegion: a.Region,
          lastLocation: a.Location,
          lastAction: a['Action Taken'],
          employeeId: empId
        };
      }
      const e = stats[emp];
      e.total += 1;
      e.types.add(a.Rejection);
      const drKey = `${a.Door}::${a.Rejection}`;
      e.doorRej[drKey] = (e.doorRej[drKey] || 0) + 1;
      if (dt > e.lastDt) {
        e.lastDt = dt;
        e.lastRegion = a.Region;
        e.lastLocation = a.Location;
        e.lastAction = a['Action Taken'];
        e.employeeId = empId;
      }
    });

    return Object.entries(stats).map(([emp, s], idx) => {
      const repeats = Object.entries(s.doorRej).filter(([, c]) => c > 1);
      let topDoor = '', topCount = 0;
      if (repeats.length) {
        const [key, cnt] = repeats.reduce((a, b) => a[1] > b[1] ? a : b);
        [topDoor] = key.split('::');
        topCount = cnt;
      }
      const [lastDate, lastTime] = s.lastDt.split(' ');
      return {
        id: idx,
        srNo: idx + 1,
        employeeId: s.employeeId,         // NEW
        lastDate,
        lastTime,
        location: s.lastLocation,
        region: s.lastRegion,
        employee: emp,
        lastAction: s.lastAction,
        total: s.total,
        repeatedDoor: topDoor,
        repeatCount: topCount,
        rejectionTypes: Array.from(s.types).join(', ')
      };
    });
  }, [alarms]);

  // 2) Door stats
  const doorStats = useMemo(() => {
    const d = {};
    alarms.forEach(a => {
      const door = a.Door || 'Unknown';
      if (!d[door]) d[door] = { total: 0, rejections: {} };
      d[door].total += 1;
      d[door].rejections[a.Rejection] = (d[door].rejections[a.Rejection]||0) + 1;
    });
    return Object.entries(d)
      .filter(([, s]) => s.total > 1)
      .map(([door, s], idx) => ({
        id: idx,
        door,
        total: s.total,
        rejectionCounts: Object.entries(s.rejections)
          .map(([t,c]) => `${t}:${c}`)
          .join(', ')
      }));
  }, [alarms]);

  // 3) Detailed raw rows
  const rawRows = useMemo(() =>
    alarms.map((a,i) => ({ id: i, ...a })), [alarms]
  );

  if (!alarms.length) {
    return (
      <Typography variant="h6" align="center" sx={{ mt: 4 }}>
        No alarm records to display.
      </Typography>
    );
  }

  // Columns for each table
  const empColumns = [
    { field: 'srNo', headerName: 'Sr. No', width: 80 },
    { field: 'employeeId', headerName: 'Employee ID', width: 120 },  // NEW
    { field: 'lastDate', headerName: 'Date', width: 120 },
    { field: 'lastTime', headerName: 'Time', width: 120 },
    { field: 'location', headerName: 'Location', width: 150 },
    { field: 'region', headerName: 'Region', width: 120 },
    { field: 'employee', headerName: 'Employee Name', width: 180 },
    { field: 'lastAction', headerName: 'Action Taken', width: 180 },
    { field: 'total', headerName: 'Total Alarms', width: 130 },
    { field: 'repeatedDoor', headerName: 'Repeated Door', width: 200 },
    { field: 'repeatCount', headerName: 'Repeat Count', width: 130 },
    { field: 'rejectionTypes', headerName: 'Types of Rejection', width: 300 },
  ];

  const doorColumns = [
    { field: 'door', headerName: 'Door', width: 300 },
    { field: 'total', headerName: 'Total Alarms', width: 150 },
    { field: 'rejectionCounts', headerName: 'Rejection Counts', width: 400 }
  ];

  const rawColumns = [
    { field: 'Sr. No', headerName: 'Sr. No', width: 90 },
    { field: 'Date', headerName: 'Date', width: 120 },
    { field: 'Time of  Alarm (Local time)', headerName: 'Time', width: 150 },
    { field: 'Employee ID No', headerName: 'Employee ID', width: 150 },  // NEW
    { field: 'Type of Alarm', headerName: 'Type', width: 150 },
    { field: 'Door', headerName: 'Door', width: 250 },
    { field: 'Location', headerName: 'Location', width: 150 },
    { field: 'Region', headerName: 'Region', width: 120 },
    { field: 'Rejection', headerName: 'Rejection', width: 180 },
    { field: 'CCURE Incident Priority', headerName: 'Priority', width: 150 },
    {
      field: 'Name of Person Attending Alarms (First, Last Name)',
      headerName: 'Operator', width: 200
    },
    { field: 'Action Taken', headerName: 'Action Taken', width: 150 },
    { field: ' Time Taken (Min)', headerName: 'Time Taken (Min)', width: 150 }
  ];

  return (
    <div style={{ width: '100%', height: '100%' }}>
      {tableType === 'employee' && (
        <DataGrid
          rows={employeeStats}
          columns={empColumns}
          pageSize={maxRows}
          rowsPerPageOptions={[maxRows]}
          autoHeight={false}
        />
      )}

      {tableType === 'door' && (
        <DataGrid
          rows={doorStats}
          columns={doorColumns}
          pageSize={Math.min(5, maxRows)}
          rowsPerPageOptions={[Math.min(5, maxRows)]}
          autoHeight={false}
        />
      )}

      {tableType === 'detailed' && (
        <>
          <Button variant="contained" color="primary" onClick={exportToExcel} sx={{ mb: 2 }}>
            Export to Excel
          </Button>
          <DataGrid
            rows={rawRows}
            columns={rawColumns}
            getRowClassName={params =>
              params.row[' Time Taken (Min)'] > 0 ? 'sla-breach' : ''
            }
            pageSize={maxRows}
            rowsPerPageOptions={[10, 20, 50].filter(x => x <= rawRows.length)}
            autoHeight={false}
          />
        </>
      )}
    </div>
  );
};

export default AlarmsTable;




File 3



// src/components/Chart.js
import React, { useEffect, useRef } from 'react';
import Chart from 'chart.js/auto';
// import Chart from 'chart.js/auto';
import ChartDataLabels from 'chartjs-plugin-datalabels';

// stronger, fixed palette
const defaultColors = [
  '#3366CC', '#DC3912', '#FF9900', '#109618',
  '#990099', '#0099C6', '#DD4477', '#66AA00',
  '#B82E2E', '#316395'
];

export default function MyChart({
  type = 'bar',
  data,
  options = {},
  width = '100%',
  height = '100%'
}) {
  const canvasRef = useRef(null);
  const chartRef  = useRef(null);

  //Register the datalabels plugin once
  useEffect(() => {
    Chart.register(ChartDataLabels);
  }, []);

  useEffect(() => {
    if (!canvasRef.current) return;
    const ctx = canvasRef.current.getContext('2d');
    // chartRef.current?.destroy();
    if(chartRef.current)chartRef.current.destroy();

    // Prepare datasets with boxed labels
    const datasets = Array.isArray(data.datasets)
      ? data.datasets.map(ds => ({
          ...ds,
          borderWidth: 2,
          fill: ds.fill ?? false,
          datalabels: {
            display: true,
            formatter: v => v,
            font: { weight: 'bold' },
            color: '#000',
            backgroundColor: 'rgba(255,255,255,0.8)',
            borderRadius: 4,
            padding: 4,
            anchor: 'end',
            align: 'top',
            clip: false  // allow beyond chart area
          }
        }))
      : (() => {
          const bg = data.bgColors || defaultColors.slice(0, data.values.length);
          const border = data.borderColor || bg;
          return [{
            label: data.label || '',
            data: data.values,
            backgroundColor: bg,
            borderColor: border,
            borderWidth: 2,
            ...(type === 'line' && { tension: 0.3, pointRadius: 6 }),
            datalabels: {
              display: true,
              formatter: v => v,
              font: { weight: 'bold' },
              color: '#000',
              backgroundColor: 'rgba(255,255,255,0.8)',
              borderRadius: 4,
              padding: 4,
              anchor: 'end',
              align: 'top',
              clip: false
            }
          }];
        })();

    chartRef.current = new Chart(ctx, {
      type,
      data: {
        labels: data.labels,
        datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: { duration: 800 },
        plugins: {
          legend: { labels: { font: { size: 14 } } },
          datalabels: {
            // ensure labels can render outside dataset elements
            clip: false
          }
        },
        scales: {
          x: { beginAtZero: true, ...(options.scales?.x || {}) },
          y: { beginAtZero: true, ...(options.scales?.y || {}) }
        },
        ...options
      }
    });

    return () => chartRef.current?.destroy();
  }, [type, data, options]);

  return (
    <div style={{ width, height, border: '1px solid #ccc', borderRadius: 4, padding: 8 }}>
      <canvas ref={canvasRef} />
    </div>
  );
}



File 4

Summarycard.js


// src/components/SummaryCards.js
import React from 'react';
import MyChart from './Chart';
import { Card, CardContent, Typography, Grid } from '@mui/material';

const PRIORITY_COLORS = {
  High: '#DC3912',
  Medium: '#FF9900',
  Low: '#109618'
};

const defaultColors = [
  '#FF9900','#109618','#FED06A','#DC3912',
  '#990099','#0099C6','#C1D82F','#66AA00',
  '#3366CC','#B82E2E','#316395','#71C9CD'
];

const REJECTION_COLORS = [
  '#006400','#00008B','#8B008B','#FF1493',
  '#00CED1','#2F4F4F','#6f1c03','#ff9a00'
];

const REJECTION_COLOR_MAP = {
  'Wrong Pin':'#49A044','Facility code':'#49A044',
  'Unknown card':'#49A044','Not activated':'#49A044',
  'Site code':'#49A044','Clearance - Access Violation':'#FFDF00',
  'Expired':'#FFDF00','Lost':'#FFDF00',
  'Disabled Badge':'#FFA500','Duress Alarm':'#FFA500',
};

// helper: "01-Apr-25" → "Apr 25"
const formatMonthYear = dateStr => {
  const [ , mon, yy ] = dateStr.split('-');
  return `${mon} ${yy}`;
};

export default function SummaryCards({ summary, filters, rawAlarms }) {
  if (!summary) return null;

  const {
    rejectionTypeWise = {},
    regionWise = {},
    monthWise = {},
    locationWise = {},
    operatorWise = {}
  } = summary;

  // apply filters
  const filtered = rawAlarms.filter(a => {
    if (filters.region   && a.Region   !== filters.region)                         return false;
    if (filters.location && a.Location !== filters.location)                       return false;
    if (filters.month    && formatMonthYear(a.Date) !== filters.month)             return false;
    if (filters.priority && a['CCURE Incident Priority'] !== filters.priority)     return false;
    return true;
  });

  // 1) Rejection Stats
  const rejectionCounts = filtered.reduce((acc, a) => {
    acc[a.Rejection] = (acc[a.Rejection] || 0) + 1;
    return acc;
  }, {});
  const rejectionStats = Object.entries(rejectionCounts)
    .map(([type,count],i) => {
      const pct = filtered.length
        ? `${((count/filtered.length)*100).toFixed(2)}%`
        : '0%';
      return {
        type, count, percentage: pct,
        color: REJECTION_COLOR_MAP[type]
          || REJECTION_COLORS[i % REJECTION_COLORS.length]
      };
    })
    .sort((a,b)=>b.count-a.count);

  // 2) Priority Wise
  const prCounts = filtered.reduce((acc,a)=> {
    const p = a['CCURE Incident Priority'];
    acc[p] = (acc[p]||0)+1;
    return acc;
  }, {});
  const prLabels = Object.keys(prCounts);
  const prValues = prLabels.map(l=>prCounts[l]);
  const prColors = prLabels.map(l=>PRIORITY_COLORS[l]||'#999');

  // 3) Operator Wise (from summary.operatorWise)
  const opLabels = Object.keys(operatorWise);
  const opValues = opLabels.map(l=>operatorWise[l].count||0);
  const opColors = defaultColors.slice(0,opLabels.length);

  // 4) Partition (region or location)
  const partitionObj = !filters.region
    ? Object.fromEntries(Object.entries(regionWise).map(([r,i])=>[r,i.count||0]))
    : filtered.reduce((acc,a)=>{ acc[a.Location]=(acc[a.Location]||0)+1; return acc; }, {});
  const partLabels = Object.keys(partitionObj);
  const partValues = partLabels.map(l=>partitionObj[l]);
  const partColors = defaultColors.slice(0,partLabels.length);

  // 5) Month Wise
  const monthCounts = filtered.reduce((acc,a)=>{
    const key = formatMonthYear(a.Date);
    acc[key]=(acc[key]||0)+1; return acc;
  }, {});
  const monthOrder = Object.keys(monthCounts).sort((a,b)=>{
    // parse back to date to sort
    const [mA,yA] = a.split(' '), [mB,yB] = b.split(' ');
    const dA = new Date(`20${yA}-${mA}-01`);
    const dB = new Date(`20${yB}-${mB}-01`);
    return dA - dB;
  });
  const monthLabels = monthOrder;
  const monthValues = monthLabels.map(m=>monthCounts[m]);
  const monthColors = defaultColors.slice(0,monthLabels.length);

  // 6) Location Wise
  const locCounts = filtered.reduce((acc,a)=>{ acc[a.Location]=(acc[a.Location]||0)+1; return acc; }, {});
  const locLabels = Object.keys(locCounts);
  const locValues = locLabels.map(l=>locCounts[l]);
  const locColors = defaultColors.slice(0,locLabels.length);

  // 7) Priority by Location
  const locations = [...new Set(filtered.map(a=>a.Location))];
  const priorities = ['Low','Medium','High','Critical'];
  const seriesData = priorities.map((prio,i)=>({
    label: prio,
    data: locations.map(loc=>
      filtered.filter(a=>
        a.Location===loc && a['CCURE Incident Priority']===prio
      ).length
    ),
    borderColor: PRIORITY_COLORS[prio]||defaultColors[i%defaultColors.length],
    backgroundColor: 'transparent'
  }));

  return (
    <>
      {/* Rejection Cards */}
      <Grid container spacing={2} sx={{mb:2}}>
        {rejectionStats.map(r=>(
          <Grid item xs={12} sm={6} md={3} key={r.type}>
            <Card sx={{border:`2px solid ${r.color}`,bgcolor:r.color,color:'#fff'}}>
              <CardContent>
                <Typography variant="subtitle2">{r.type}</Typography>
                <Typography variant="h6">{r.count}</Typography>
                <Typography variant="body2">{r.percentage}</Typography>
              </CardContent>
            </Card>
          </Grid>
        ))}
      </Grid>

      {/* Partition / Priority / Location */}
      <Grid container spacing={5} sx={{mb:4}}>
        {/* partition */}
        {partLabels.length>0 && (
          <Grid item xs={400} md={200}>
            <Card><CardContent>
              <Typography variant="h6" gutterBottom>
                {!filters.region?'Global Partition':`${filters.region} → Location`}
              </Typography>
              <MyChart
                type="doughnut"
                data={{labels:partLabels,values:partValues,bgColors:partColors,borderColor:partColors}}
                height={500} width={600}
              />
            </CardContent></Card>
          </Grid>
        )}
        {/* priority */}
        {prLabels.length>0 && (
          <Grid item xs={400} md={200}>
            <Card><CardContent>
              <Typography variant="h6" gutterBottom>Priority Wise</Typography>
              <MyChart
                type="pie"
                data={{labels:prLabels,values:prValues,bgColors:prColors,borderColor:prColors}}
                height={500} width={600}
              />
            </CardContent></Card>
          </Grid>
        )}
        {/* location */}
        {locLabels.length>0 && (
          <Grid item xs={400} md={200}>
            <Card><CardContent>
              <Typography variant="h6" gutterBottom>Location Wise</Typography>
              <MyChart
                type="line"
                data={{labels:locLabels,values:locValues,bgColors:locColors,borderColor:locColors}}
                options={{
                  scales:{
                    x:{title:{display:true,text:'Location'}},
                    y:{title:{display:true,text:'Alarm Count'}}
                  }
                }}
                height={550} width={750}
              />
            </CardContent></Card>
          </Grid>
        )}
      </Grid>

      {/* P-by-L, Month & Operator in one row */}
      <Grid container spacing={5} sx={{mb:4}}>
        {/* Priority by Location */}
        <Grid item xs={400} md={200}>
          <Card><CardContent>
            <Typography variant="h6" gutterBottom>Priority by Location</Typography>
            <MyChart
              type="line"
              data={{labels:locations,datasets:seriesData}}
              options={{
                scales:{
                  x:{title:{display:true,text:'Location'}},
                  y:{title:{display:true,text:'Alarm Count'}}
                },
                plugins:{legend:{position:'bottom'}}
              }}
              height={500} width={750}
            />
          </CardContent></Card>
        </Grid>

        {/* Month Wise */}
        <Grid item xs={5} md={4}>
          <Card><CardContent>
            <Typography variant="h6" gutterBottom>Month Wise</Typography>
            <MyChart
              type="line"
              data={{labels:monthLabels,values:monthValues,bgColors:monthColors,borderColor:monthColors}}
              options={{
                scales:{
                  x:{title:{display:true,text:'Month'}},
                  y:{title:{display:true,text:'Alarm Count'}}
                }
              }}
              height={500} width={600}
            />
          </CardContent></Card>
        </Grid>

        {/* Operator Wise */}
        <Grid item xs={5} md={4}>
          <Card><CardContent>
            <Typography variant="h6" gutterBottom>Operator Wise</Typography>
            <MyChart
              type="bar"
              data={{labels:opLabels,values:opValues,bgColors:opColors,borderColor:opColors}}
              options={{
                scales:{
                  x:{title:{display:true,text:'Operator'}},
                  y:{title:{display:true,text:'Alarm Count'}}
                }
              }}
              height={500} width={600}
            />
          </CardContent></Card>
        </Grid>
      </Grid>
    </>
  );
}


