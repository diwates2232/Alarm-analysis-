import React from 'react';
import { Card, CardContent, Typography, Grid } from '@mui/material';

export default function AlarmCard({ summary, rawAlarms, filters }) {
  if (!summary) return null;

  // Compute dynamic total:
  const totalAlarms = rawAlarms.filter(a => {
    if (filters.region && a.Region !== filters.region) return false;
    if (filters.location && a.Location !== filters.location) return false;
    return true;
  }).length;

  // Compute dynamic responseSentPercentage:
  const sentCount = rawAlarms.filter(a => {
    if (filters.region && a.Region !== filters.region) return false;
    if (filters.location && a.Location !== filters.location) return false;
    return a['Action Taken'] && a['Action Taken'] !== 'Not Sent';
  }).length;
  const responseSentPercentage = totalAlarms
    ? `${((sentCount / totalAlarms) * 100).toFixed(2)}%`
    : '0%';

  return (
    <Grid container spacing={2} sx={{ mb: 3 }}>
      <Grid item xs={12} sm={6} md={3}>
        <Card>
          <CardContent>
            <Typography variant="subtitle1" gutterBottom>
              Total Alarms
            </Typography>
            <Typography variant="h4">
              {totalAlarms}
            </Typography>
          </CardContent>
        </Card>
      </Grid>
      <Grid item xs={12} sm={6} md={3}>
        <Card>
          <CardContent>
            <Typography variant="subtitle1" gutterBottom>
              Response Sent %
            </Typography>
            <Typography variant="h4">
              {responseSentPercentage}
            </Typography>
          </CardContent>
        </Card>
      </Grid>
    </Grid>
  );
}








import React from 'react';
import './SummaryCards.css';
import MyChart from './Chart';
import { Card, CardContent, Typography, Grid, Box } from '@mui/material';

// Priority palette
const PRIORITY_COLORS = {
  Low: '#90ee90',
  Medium: '#ffff00',
  High: '#ff0000'
};

export default function SummaryCards({ summary, filters, rawAlarms }) {
  if (!summary) return null;

  // === Build dynamic priority data ===
  const filtered = rawAlarms.filter(a => {
    if (filters.region && a.Region !== filters.region) return false;
    if (filters.location && a.Location !== filters.location) return false;
    return true;
  });
  const total = filtered.length;
  const counts = filtered.reduce((acc, a) => {
    const p = a['CCURE Incident Priority'];
    acc[p] = (acc[p] || 0) + 1;
    return acc;
  }, {});
  const labels = Object.keys(counts);
  const values = labels.map(l => counts[l]);
  const bg = labels.map(l => PRIORITY_COLORS[l] || '#ccc');

  // === Prepare the rest of your charts as before ===
  const makeChartData = (key, obj) => {
    const labels = Object.keys(obj);
    const values = labels.map(l => obj[l].count);
    const colors = labels.map(() => '#8884d8');
    return { labels, values, bgColors: colors, borderColor: colors };
  };

  const partitionObj = !filters.region
    ? summary.regionWise
    : { [filters.region]: summary.regionWise[filters.region] };

  const configs = [
    { key: 'partition',    title: !filters.region ? 'Global Partition' : `${filters.region} Partition`, type: 'doughnut', dataObj: partitionObj },
    filters.region && { key: 'locationWise', title: 'Location Wise', type: 'line', dataObj: summary.locationWise },
    { key: 'operatorWise', title: 'Operator Wise',      type: 'bar',  dataObj: summary.operatorWise },
    { key: 'monthWise',    title: 'Month Wise',         type: 'line', dataObj: summary.monthWise }
  ].filter(Boolean);

  return (
    <>
      {/* Priority Wise Pie */}
      <Grid container spacing={2} sx={{ mb: 4 }}>
        <Grid item xs={12} md={4}>
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                Priority Wise
              </Typography>
              <MyChart
                type="pie"
                data={{ labels, values, bgColors: bg, borderColor: bg }}
                height={250}
              />
            </CardContent>
          </Card>
        </Grid>
      </Grid>

      {/* Other Charts */}
      <Grid container spacing={2}>
        {configs.map(({ key, title, type, dataObj }) => {
          if (!dataObj || Object.keys(dataObj).length === 0) return null;
          const options = type === 'line' ? {
            scales: {
              x: { title: { display: true, text: key==='monthWise'? 'Month':'Location' } },
              y: { title: { display: true, text: 'Alarm Count' } }
            }
          } : {};

          return (
            <Grid item xs={12} md={key==='partition'?6:4} key={key}>
              <Card>
                <CardContent>
                  <Typography variant="h6" gutterBottom>
                    {title}
                  </Typography>
                  <MyChart
                    type={type}
                    data={makeChartData(key, dataObj)}
                    options={options}
                    height={240}
                  />
                </CardContent>
              </Card>
            </Grid>
          );
        })}
      </Grid>
    </>
  );
}










read Carefully Blow js file .

issue is there Total Alarm Count , Responce Sent, & Priority Wise chart are not Update Count When region is change.it only read Count Globally.
I want Update Alarm count , Responce sent percentage count  , Priority Wise count chart update as per region 
make sure Dont change Another function .
Another charts and cards  remain same.

read Below js file acarefully and give me Updated js files.



File 1 

AlarmCared.js


import React from 'react';
import { Card, CardContent, Typography, Grid } from '@mui/material';

export default function AlarmCard({ summary }) {
  if (!summary) return null;

  return (
    <Grid container spacing={2} sx={{ mb: 3 }}>
      <Grid item xs={20} sm={5} md={3}>
        <Card>
          <CardContent>
            <Typography variant="subtitle1" gutterBottom>
              Total Alarms
            </Typography>
            <Typography variant="h4">
              {summary.totalAlarms}
            </Typography>
          </CardContent>
        </Card>
      </Grid>
      <Grid item xs={20} sm={5} md={3}>
        <Card>
          <CardContent>
            <Typography variant="subtitle1" gutterBottom>
              Response Sent %
            </Typography>
            <Typography variant="h4">
              {summary.responseSentPercentage}
            </Typography>
          </CardContent>
        </Card>
      </Grid>
    </Grid>
  );
}



File 2

Chart.js



import React, { useEffect, useRef } from 'react';
import Chart from 'chart.js/auto';

export default function MyChart({
  type = 'bar',
  data,
  options = {},
  width = '100%',
  height = 400
}) {
  const canvasRef = useRef(null);
  const chartRef  = useRef(null);

  useEffect(() => {
    if (!canvasRef.current) return;
    const ctx = canvasRef.current.getContext('2d');
    if (chartRef.current) chartRef.current.destroy();

    // Build dataset with line-chart specifics if needed
    const ds = {
      label: data.label || '',
      data: data.values,
      backgroundColor: data.bgColors,
      borderColor: data.borderColor,
      borderWidth: 2,
      fill: type === 'line' ? false : true,
      tension: type === 'line' ? 0.4 : 0,
      pointBackgroundColor: data.borderColor,
      pointRadius: type === 'line' ? 4 : undefined,
    };

    chartRef.current = new Chart(ctx, {
      type,
      data: {
        labels: data.labels,
        datasets: [ds],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        ...options,
      }
    });

    return () => chartRef.current && chartRef.current.destroy();
  }, [type, data, options]);

  return (
    <div style={{ width, height }}>
      <canvas ref={canvasRef} />
    </div>
  );
}




File 3 

Filters.js



import React from 'react';
import { TextField, MenuItem } from '@mui/material';

const Filters = ({
  filters,
  setFilters,
  regionOptions = [],
  locationOptions = []
}) => {
  const handleChange = (field) => (e) =>
    setFilters(prev => ({
      ...prev,
      [field]: e.target.value,
      ...(field === 'region' && { location: '' })
    }));

  return (
    <div style={{ display: 'flex', gap: '1rem', marginBottom: 16 }}>
      <TextField
        select
        label="Region"
        value={filters.region}
        onChange={handleChange('region')}
        style={{ minWidth: 150 }}
      >
        <MenuItem value="">Global</MenuItem>
        {regionOptions.map(region => (
          <MenuItem key={region} value={region}>
            {region}
          </MenuItem>
        ))}
      </TextField>

      {filters.region && (
        <TextField
          select
          label="Location"
          value={filters.location}
          onChange={handleChange('location')}
          style={{ minWidth: 200 }}
        >
          <MenuItem value="">All Locations</MenuItem>
          {locationOptions.map(loc => (
            <MenuItem key={loc} value={loc}>
              {loc}
            </MenuItem>
          ))}
        </TextField>
      )}
    </div>
  );
};

export default Filters;



File 4

SummaryCards.js



import React from 'react';
import './SummaryCards.css';
import MyChart from './Chart';
import { Card, CardContent, Typography, Grid, Box } from '@mui/material';

// Palette for rejection-type cards
const REJECTION_COLORS = [
  '#007bff', '#28a745', '#ffc107',
  '#dc3545', '#6f42c1', '#17a2b8',
  '#fd7e14', '#20c997', '#6c757d',
  '#6610f2',
];

// Build rejection stats in the current context
function getRejectionStats(summary, rawAlarms, filters) {
  let entries;
  if (!filters.region) {
    // Global
    entries = Object.entries(summary.rejectionTypeWise);
    return entries.map(([type, info], idx) => ({
      type,
      count: info.count,
      percentage: info.percentage,
      color: REJECTION_COLORS[idx % REJECTION_COLORS.length]
    }));
  } else if (filters.region && !filters.location) {
    // Region
    const total = summary.regionWise[filters.region].count;
    const byType = rawAlarms.filter(a => a.Region === filters.region)
      .reduce((acc, a) => {
        acc[a.Rejection] = (acc[a.Rejection] || 0) + 1;
        return acc;
      }, {});
    return Object.entries(byType).map(([type, count], idx) => ({
      type,
      count,
      percentage: total ? `${((count/total)*100).toFixed(2)}%` : '0%',
      color: REJECTION_COLORS[idx % REJECTION_COLORS.length]
    }));
  } else {
    // Location
    const total = summary.locationWise[filters.location]?.count || 0;
    const byType = rawAlarms.filter(a =>
      a.Region === filters.region && a.Location === filters.location
    ).reduce((acc, a) => {
      acc[a.Rejection] = (acc[a.Rejection] || 0) + 1;
      return acc;
    }, {});
    return Object.entries(byType).map(([type, count], idx) => ({
      type,
      count,
      percentage: total ? `${((count/total)*100).toFixed(2)}%` : '0%',
      color: REJECTION_COLORS[idx % REJECTION_COLORS.length]
    }));
  }
}

export default function SummaryCards({ summary, filters, rawAlarms }) {
  if (!summary) return null;
  const rejectionStats = getRejectionStats(summary, rawAlarms, filters);

  // Helper to build chart data
  const makeChartData = (key, obj) => {
    const labels = Object.keys(obj);
    const values = labels.map(l => obj[l].count);
    const colors = labels.map((_,i) => REJECTION_COLORS[i % REJECTION_COLORS.length]);
    return { labels, values, bgColors: colors, borderColor: colors };
  };

  // Partition object
  const partitionObj = !filters.region
    ? summary.regionWise
    : { [filters.region]: summary.regionWise[filters.region] };

  // Chart configs (dropping rejectionTypeWise pie)
  const configs = [
    { key: 'partition',    title: !filters.region ? 'Global Partition' : `${filters.region} Partition`, type: 'doughnut', dataObj: partitionObj },
    filters.region && {   key: 'locationWise', title: 'Location Wise', type: 'line', dataObj: summary.locationWise },
    { key: 'priorityWise', title: 'Priority Wise',      type: 'pie',  dataObj: summary.priorityWise },
    { key: 'operatorWise', title: 'Operator Wise',      type: 'bar',  dataObj: summary.operatorWise },
    { key: 'monthWise',    title: 'Month Wise',         type: 'line', dataObj: summary.monthWise }

    // filters.region && {   key: 'locationWise', title: 'Location Wise', type: 'line', dataObj: summary.locationWise }
  ].filter(Boolean);

  return (
    <Grid container spacing={2}>
      {/* Left column: Rejection-Type cards */}
      <Grid item xs={20} md={3}>
        <Grid container spacing={2}>
          {rejectionStats.map(({ type, count, percentage, color }) => (
            <Grid item xs={12} key={type}>
              <Card sx={{ borderLeft: `6px solid ${color}` }}>
                <CardContent>
                  <Typography variant="subtitle2">{type}</Typography>
                  <Typography variant="h6">{count}</Typography>
                  <Typography variant="body2" color="textSecondary">
                    {percentage}
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
          ))}
        </Grid>
      </Grid>

      {/* Right column: Other charts in 2×2 (or 2×3 if locationWise appears) */}
      <Grid item xs={20} md={10}>
        <Grid container spacing={2}>
          {configs.map(({ key, title, type, dataObj }) => {
            if (!dataObj || Object.keys(dataObj).length === 0) return null;
            const options = (type === 'line') ? {
              scales: {
                x: { title: { display: true, text: key==='monthWise'? 'Month' : 'Location' } },
                y: { title: { display: true, text: 'Alarm Count' } }
              }
            } : {};

            return (
              <Grid item xs={20} md={filters.region ? 10 : 4} key={key}>
                <Card>
                  <CardContent>
                    <Typography variant="h6" gutterBottom>
                      {title}
                    </Typography>
                    <MyChart
                      type={type}
                      data={makeChartData(key, dataObj)}
                      options={options}
                      height={200}
                    />
                  </CardContent>
                </Card>
              </Grid>
            );
          })}
        </Grid>
      </Grid>
    </Grid>
  );
}




File 5

Dashboard.js




// src/pages/Dashboard.js
import React, { useEffect, useState, useMemo, useRef } from 'react';
import { Container, Typography } from '@mui/material';
import Filters      from '../components/Filters';
import SummaryCards from '../components/SummaryCards';
import AlarmCard    from '../components/AlarmCard';
import { getAlarmSummary, getRawAlarms } from '../services/api';

export default function Dashboard() {
  const [summary, setSummary]     = useState(null);
  const [rawAlarms, setRawAlarms] = useState([]);
  const [filters, setFilters]     = useState({ region: '', location: '' });

  // 1) Fetch data once
  useEffect(() => {
    Promise.all([ getAlarmSummary(), getRawAlarms() ])
      .then(([sumRes, rawRes]) => {
        setSummary(sumRes.data);
        setRawAlarms(rawRes.data);
      })
      .catch(console.error);
  }, []);

  // 2) Memoize regionOptions so it only changes when summary changes
  const regionOptions = useMemo(() => {
    return summary ? Object.keys(summary.regionWise) : [];
  }, [summary]);

  // 3) Build a map of region → [locations], memoized on rawAlarms and regionOptions
  const regionLocationsMap = useMemo(() => {
    const map = {};
    regionOptions.forEach(region => {
      map[region] = Array.from(
        new Set(
          rawAlarms
            .filter(a => a.Region === region)
            .map(a => a.Location)
        )
      );
    });
    return map;
  }, [rawAlarms, regionOptions]);

  // 4) Build and start slideshow as soon as summary is available
  const slidesRef = useRef([]);
  const slideIdx  = useRef(0);

  useEffect(() => {
    if (!summary) return;   // wait for data

    // Build slides: global → each region → each location
    // const slides = [{ region: '', location: '' }];
    // regionOptions.forEach(region => {
    //   slides.push({ region, location: '' });
    //   regionLocationsMap[region].forEach(location => {
    //     slides.push({ region, location });
    //   });
    // });

    const slides = [{ region: '', location: '' }];
       regionOptions.forEach(region => {
         slides.push({ region, location: '' });
       });

    slidesRef.current = slides;
    slideIdx.current = 0;

    // Immediately show “Global”
    setFilters(slides[0]);

    // Every 60s, advance to the next slide
    const intervalId = setInterval(() => {
      slideIdx.current = (slideIdx.current + 1) % slidesRef.current.length;
      setFilters(slidesRef.current[slideIdx.current]);
    }, 30_000);

    return () => clearInterval(intervalId);
  }, [summary, regionOptions, regionLocationsMap]);

  // 5) Compute filteredSummary exactly as before
  const filteredSummary = useMemo(() => {
    if (!summary) return null;
    const fs = { ...summary };
    if (filters.region) {
      fs.regionWise   = { [filters.region]: summary.regionWise[filters.region] };
      fs.locationWise = {};
      (regionLocationsMap[filters.region] || [])
        .filter(loc => !filters.location || loc === filters.location)
        .forEach(loc => {
          fs.locationWise[loc] = summary.locationWise[loc];
        });
    }
    return fs;
  }, [summary, filters, regionLocationsMap]);

  // 6) Render
  if (!summary) {
    return <Typography>Loading dashboard…</Typography>;
  }

  return (
    <Container sx={{ py: 4 }}>
      <Typography variant="h4" gutterBottom>
        Alarm Analysis Dashboard
      </Typography>

      <Filters
        filters={filters}
        setFilters={setFilters}
        regionOptions={regionOptions}
        locationOptions={filters.region ? regionLocationsMap[filters.region] : []}
      />

      <AlarmCard summary={summary} />

      <SummaryCards
        summary={filteredSummary}
        filters={filters}
        rawAlarms={rawAlarms}
      
        
      />
    </Container>
  );
}






