// src/components/Chart.js
import React, { useEffect, useRef } from 'react';
import Chart from 'chart.js/auto';               // ensure v3+
import ChartDataLabels from 'chartjs-plugin-datalabels';
Chart.register(ChartDataLabels);

export default function MyChart({
  type = 'bar',
  data,          // { labels, values, bgColors, borderColor } or { labels, datasets }
  options = {},
  width = '100%',
  height = '100%'
}) {
  const canvasRef = useRef(null);
  const chartRef  = useRef(null);

  useEffect(() => {
    if (!canvasRef.current) return;
    const ctx = canvasRef.current.getContext('2d');
    chartRef.current?.destroy();

    const isLine = type === 'line';

    // Build datasets array
    const rawDatasets = Array.isArray(data.datasets)
      ? data.datasets
      : [{
          label: data.label || '',
          data: data.values || [],
          backgroundColor: data.bgColors   || [],
          borderColor:     data.borderColor|| []
        }];

    const datasets = rawDatasets.map(ds => {
      // ensure arrays
      const bgArr     = Array.isArray(ds.backgroundColor) ? ds.backgroundColor : [ds.backgroundColor];
      const strokeArr = Array.isArray(ds.borderColor)     ? ds.borderColor     : [ds.borderColor];

      return {
        ...ds,
        borderWidth: 2,
        // no single borderColor here — segments will be colored below
        backgroundColor: isLine ? 'transparent' : bgArr,
        pointBackgroundColor: isLine ? bgArr : undefined,
        pointBorderColor:     isLine ? strokeArr : undefined,
        fill: isLine ? false : ds.fill ?? false,
        ...(isLine && {
          tension: 0.3,
          pointRadius: 6,
          // Segment hook: color each line segment from your strokeArr
          segment: {
            borderColor: ctx => {
              // ctx.p0DataIndex = starting point index of this segment
              const i = ctx.p0DataIndex;
              return strokeArr[i % strokeArr.length];
            }
          }
        }),
        datalabels: {
          display: true,
          formatter: v => v,
          font: { weight: 'bold' },
          backgroundColor: 'rgba(255,255,255,0.8)',
          borderRadius: 4,
          padding: 4,
          anchor: 'end',
          align: 'top',
          clip: false
        }
      };
    });

    chartRef.current = new Chart(ctx, {
      type,
      data: { labels: data.labels, datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: { duration: 800 },
        plugins: {
          legend: { labels: { font: { size: 14 } } },
          datalabels: { clip: false }
        },
        scales: {
          x: { beginAtZero: true, ...(options.scales?.x || {}) },
          y: { beginAtZero: true, ...(options.scales?.y || {}) }
        },
        ...options
      }
    });

    return () => chartRef.current?.destroy();
  }, [type, data, options]);

  return (
    <div style={{ width, height, border: '1px solid #ccc', borderRadius: 4, padding: 8 }}>
      <canvas ref={canvasRef} />
    </div>
  );
}










Read both file carefully and solve this issue.


// src/components/Chart.js


import React, { useEffect, useRef } from 'react';
import Chart from 'chart.js';
import ChartDataLabels from 'chartjs-plugin-datalabels';
Chart.plugins.register(ChartDataLabels);

export default function MyChart({
  type = 'bar',
  data,
  options = {},
  width = '100%',
  height = '100%'
}) {
  const canvasRef = useRef(null);
  const chartRef  = useRef(null);

  useEffect(() => {
    if (!canvasRef.current) return;
    const ctx = canvasRef.current.getContext('2d');
    chartRef.current?.destroy();

    const isLine = type === 'line';

    const datasets = Array.isArray(data.datasets)
      ? data.datasets.map(ds => {
          // for multi-series you must supply ds.borderColor and ds.backgroundColor arrays
          return {
            ...ds,
            borderWidth: 2,
            // for line: ds.borderColor must be an array of exact colours
            borderColor: isLine
              ? ds.borderColor
              : ds.borderColor || ds.backgroundColor,
            // fill under line is off
            backgroundColor: isLine
              ? 'transparent'
              : ds.backgroundColor,
            // colour each point from the same array
            pointBackgroundColor: isLine
              ? ds.backgroundColor
              : undefined,
            pointBorderColor: isLine
              ? ds.borderColor
              : undefined,


            fill: isLine ? false : ds.fill ?? false,
            ...(isLine && { tension: 0.3, pointRadius: 6 }),
            datalabels: {
              display: true,
              formatter: v => v,
              font: { weight: 'bold' },
              backgroundColor: 'rgba(255,255,255,0.8)',
              borderRadius: 4,
              padding: 4,
              anchor: 'end',
              align: 'top',
              clip: false
            }
          };
        })
      : (() => {
          // single-series fallback: pull your arrays
          const vals = data.values || [];
          
          const bgArray     = data.bgColors   || [];
          const strokeArray = data.borderColor || bgArray;
          return [{
            label: data.label || '',
            data: vals,
            borderWidth: 2,
            // line segments in your exact strokeArray
            borderColor: isLine
              ? strokeArray
              : strokeArray,
            // no fill under line
            backgroundColor: isLine
              ? 'transparent'
              : bgArray,
            // each dot coloured from bgArray
            pointBackgroundColor: isLine
              ? bgArray
               : undefined,
            pointBorderColor: isLine
              ? strokeArray
              : undefined,
            fill: isLine ? false : true,
            ...(isLine && { tension: 0.3, pointRadius: 6 }),
            datalabels: {
              display: true,
              formatter: v => v,
              font: { weight: 'bold' },
              backgroundColor: 'rgba(255,255,255,0.8)',
              borderRadius: 4,
              padding: 4,
              anchor: 'end',
              align: 'top',
              clip: false
            }
          }];
        })();

    chartRef.current = new Chart(ctx, {
      type,
      data: {
        labels: data.labels,
        datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: { duration: 800 },
        plugins: {
          legend: { labels: { font: { size: 14 } } },
          datalabels: { clip: false }
        },
        scales: {
          x: { beginAtZero: true, ...(options.scales?.x || {}) },
          y: { beginAtZero: true, ...(options.scales?.y || {}) }
        },
        ...options
      }
    });

    return () => chartRef.current?.destroy();
  }, [type, data, options]);

  return (
    <div style={{ width, height, border: '1px solid #ccc', borderRadius: 4, padding: 8 }}>
      <canvas ref={canvasRef} />
    </div>
  );
}







// src/components/SummaryCards.js



import React from 'react';
import MyChart from './Chart';
import { Card, CardContent, Typography, Grid,Box  } from '@mui/material';

const PRIORITY_COLORS = {
  High: '#DC3912',
  Medium: '#FF9900',
  Low: '#109618'
};

const defaultColors = [
  '#FF9900','#109618','#FED06A','#DC3912',
  '#990099','#0099C6','#C1D82F','#66AA00',
  '#3366CC','#B82E2E','#316395','#71C9CD'
];

const REJECTION_COLORS = [
  '#006400','#00008B','#8B008B','#FF1493',
  '#00CED1','#2F4F4F','#6f1c03','#ff9a00'
];

const REJECTION_COLOR_MAP = {
  'Wrong Pin':'#49A044','Facility code':'#49A044',
  'Unknown card':'#49A044','Not activated':'#49A044',
  'Site code':'#49A044','Clearance - Access Violation':'#FFDF00',
  'Expired':'#FFDF00','Lost':'#FFDF00',
  'Disabled Badge':'#FFA500','Duress Alarm':'#FFA500',
};

// helper: "01-Apr-25" → "Apr 25"
const formatMonthYear = dateStr => {
  const [ , mon, yy ] = dateStr.split('-');
  return `${mon} ${yy}`;
};

export default function SummaryCards({ summary, filters, rawAlarms }) {
  if (!summary) return null;

  const {
    rejectionTypeWise = {},
    regionWise = {},
    monthWise = {},
    locationWise = {},
    operatorWise = {}
  } = summary;

  // apply filters
  const filtered = rawAlarms.filter(a => {
    if (filters.region   && a.Region   !== filters.region)                         return false;
    if (filters.location && a.Location !== filters.location)                       return false;
    if (filters.month    && formatMonthYear(a.Date) !== filters.month)             return false;
    if (filters.priority && a['CCURE Incident Priority'] !== filters.priority)     return false;
    return true;
  });

  // 1) Rejection Stats
  const rejectionCounts = filtered.reduce((acc, a) => {
    acc[a.Rejection] = (acc[a.Rejection] || 0) + 1;
    return acc;
  }, {});
  const rejectionStats = Object.entries(rejectionCounts)
    .map(([type,count],i) => {
      const pct = filtered.length
        ? `${((count/filtered.length)*100).toFixed(2)}%`
        : '0%';
      return {
        type, count, percentage: pct,
        color: REJECTION_COLOR_MAP[type]
          || REJECTION_COLORS[i % REJECTION_COLORS.length]
      };
    })
    .sort((a,b)=>b.count-a.count);

  // 2) Priority Wise
  const prCounts = filtered.reduce((acc,a)=> {
    const p = a['CCURE Incident Priority'];
    acc[p] = (acc[p]||0)+1;
    return acc;
  }, {});
  const prLabels = Object.keys(prCounts);
  const prValues = prLabels.map(l=>prCounts[l]);
  const prColors = prLabels.map(l=>PRIORITY_COLORS[l]||'#999');

  // 3) Operator Wise (from summary.operatorWise)
  const opLabels = Object.keys(operatorWise);
  const opValues = opLabels.map(l=>operatorWise[l].count||0);
  const opColors = defaultColors.slice(0,opLabels.length);

  // 4) Partition (region or location)
  const partitionObj = !filters.region
    ? Object.fromEntries(Object.entries(regionWise).map(([r,i])=>[r,i.count||0]))
    : filtered.reduce((acc,a)=>{ acc[a.Location]=(acc[a.Location]||0)+1; return acc; }, {});
  const partLabels = Object.keys(partitionObj);
  const partValues = partLabels.map(l=>partitionObj[l]);
  const partColors = defaultColors.slice(0,partLabels.length);

  // 5) Month Wise
  const monthCounts = filtered.reduce((acc,a)=>{
    const key = formatMonthYear(a.Date);
    acc[key]=(acc[key]||0)+1; return acc;
  }, {});
  const monthOrder = Object.keys(monthCounts).sort((a,b)=>{
    // parse back to date to sort
    const [mA,yA] = a.split(' '), [mB,yB] = b.split(' ');
    const dA = new Date(`20${yA}-${mA}-01`);
    const dB = new Date(`20${yB}-${mB}-01`);
    return dA - dB;
  });
  const monthLabels = monthOrder;
  const monthValues = monthLabels.map(m=>monthCounts[m]);
  const monthColors = defaultColors.slice(0,monthLabels.length);

  // 6) Location Wise
  const locCounts = filtered.reduce((acc,a)=>{ acc[a.Location]=(acc[a.Location]||0)+1; return acc; }, {});
  const locLabels = Object.keys(locCounts);
  const locValues = locLabels.map(l=>locCounts[l]);
  const locColors = defaultColors.slice(0,locLabels.length);

  // 7) Priority by Location
  const locations = [...new Set(filtered.map(a=>a.Location))];
  const priorities = ['Low','Medium','High','Critical'];
  const seriesData = priorities.map((prio,i)=>({
    label: prio,
    data: locations.map(loc=>
      filtered.filter(a=>
        a.Location===loc && a['CCURE Incident Priority']===prio
      ).length
    ),
    borderColor: PRIORITY_COLORS[prio]||defaultColors[i%defaultColors.length],
    backgroundColor: 'transparent'
  }));

   return (
    <>
      {/* Rejection Cards */}
      <Grid container spacing={1} sx={{ mb: 2 }}>
        {rejectionStats.map(r => (
          <Grid item xs={3} sm={1} md={1.5} key={r.type}>
            <Card sx={{ border: `2px solid ${r.color}`, bgcolor: r.color, color: '#fff' }}>
              <CardContent>
                <Typography variant="subtitle2">{r.type}</Typography>
                <Typography variant="h6">{r.count}</Typography>
                <Typography variant="body2">{r.percentage}</Typography>
              </CardContent>
            </Card>
          </Grid>
        ))}
      </Grid>

      {/* Partition / Priority / Location */}
      <Grid container spacing={5} sx={{ mb: 4 }}>
        {partLabels.length > 0 && (
          <Grid item xs={12} sm={6} md={4}>
            <Card>
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  {!filters.region ? 'Global Partition' : `${filters.region} → Location`}
                </Typography>
                <Box width="100%" height={550}>
                  <MyChart
                    type="doughnut"
                    data={{ labels: partLabels, values: partValues, bgColors: partColors, borderColor: partColors }}
                    // remove hard-coded width/height props here
                  />
                </Box>
              </CardContent>
            </Card>
          </Grid>
        )}

        {prLabels.length > 0 && (
          <Grid item xs={12} sm={6} md={4}>
            <Card>
              <CardContent>
                <Typography variant="h6" gutterBottom>Priority Wise</Typography>
                <Box width="100%" height={550}>
                  <MyChart
                    type="pie"
                    data={{ labels: prLabels, values: prValues, bgColors: prColors, borderColor: prColors }}
                  />
                </Box>
              </CardContent>
            </Card>
          </Grid>
        )}

        {locLabels.length > 0 && (
          <Grid item xs={12} sm={12} md={4}>
            <Card>
              <CardContent>
                <Typography variant="h6" gutterBottom>Location Wise</Typography>
                <Box width="100%" height={550}>
                  <MyChart
                    type="line"
                    data={{
                      labels: locLabels,
                      values: locValues,
                      bgColors: locColors,         // your exact defaultColors slice
                      borderColor: locColors       // same array here
                    }}
                    options={{
                      scales: {
                        x: { title: { display: true, text: 'Location' } },
                        y: { title: { display: true, text: 'Alarm Count' } },
                      },
                    }}
                  />
                </Box>
              </CardContent>
            </Card>
          </Grid>
        )}
      </Grid>

      {/* P-by-L, Month & Operator in one row */}
      <Grid container spacing={5} sx={{ mb: 4 }}>
        {/* Priority by Location */}
        <Grid item xs={12} sm={6} md={4}>
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>Priority by Location</Typography>
              <Box width="100%" height={550}>
                <MyChart
                  type="line"
                  data={{ labels: locations, datasets: seriesData }}
                  options={{
                    scales: {
                      x: { title: { display: true, text: 'Location' } },
                      y: { title: { display: true, text: 'Alarm Count' } },
                    },
                    plugins: { legend: { position: 'bottom' } },
                  }}
                />
              </Box>
            </CardContent>
          </Card>
        </Grid>

        {/* Month Wise */}
        <Grid item xs={12} sm={6} md={4}>
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>Month Wise</Typography>
              <Box width="100%" height={550}>
              <MyChart
                    type="line"
                    data={{
                      labels: monthLabels,
                      values: monthValues,
                      bgColors: monthColors,       // your exact defaultColors slice
                      borderColor: monthColors     // same array here
                    }}
                    options={{
                      scales: {
                       x: { title: { display: true, text: 'Month' } },
                        y: { title: { display: true, text: 'Alarm Count' } },
                      },
                    }}
                  />
              </Box>
            </CardContent>
          </Card>
        </Grid>

        {/* Operator Wise */}
        <Grid item xs={12} sm={6} md={4}>
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>Operator Wise</Typography>
              <Box width="100%" height={550}>
                <MyChart
                  type="bar"
                  data={{ labels: opLabels, values: opValues, bgColors: opColors, borderColor: opColors }}
                  options={{
                    scales: {
                      x: { title: { display: true, text: 'Operator' } },
                      y: { title: { display: true, text: 'Alarm Count' } },
                    },
                  }}
                />
              </Box>
            </CardContent>
          </Card>
        </Grid>
      </Grid>
    </>
  );
}

