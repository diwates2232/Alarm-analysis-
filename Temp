import React from 'react';
import './SummaryCards.css';
import MyChart from './Chart';
import { Card, CardContent, Typography, Grid, Box } from '@mui/material';

// Colour palette for rejection types
const REJECTION_COLORS = [
  '#007bff', '#28a745', '#ffc107',
  '#dc3545', '#6f42c1', '#17a2b8',
  '#fd7e14', '#20c997', '#6c757d',
  '#6610f2'
];

export default function SummaryCards({ summary, filters, rawAlarms }) {
  if (!summary) return null;

  // GLOBAL VIEW: region pie + rejection cards
  if (!filters.region) {
    // 1) Region partition pie
    const regions = Object.entries(summary.regionWise);
    const regionLabels = regions.map(([r]) => r);
    const regionValues = regions.map(([_, info]) => info.count);
    const regionColors = regionLabels.map((_, i) => REJECTION_COLORS[i % REJECTION_COLORS.length]);

    // 2) Rejection cards
    const rejections = Object.entries(summary.rejectionTypeWise);

    return (
      <>
        <Grid container spacing={2} sx={{ mb: 4, justifyContent: 'center' }}>
          <Grid item xs={12} md={6}>
            <Card>
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  Global Region Split
                </Typography>
                <MyChart
                  type="doughnut"
                  data={{
                    labels: regionLabels,
                    values: regionValues,
                    bgColors: regionColors,
                    borderColor: regionColors
                  }}
                  height={300}
                />
              </CardContent>
            </Card>
          </Grid>
        </Grid>

        <Grid container spacing={2}>
          {rejections.map(([type, info], idx) => (
            <Grid item xs={12} sm={6} md={3} key={type}>
              <Card>
                <CardContent>
                  <Typography variant="subtitle1">
                    {type}
                  </Typography>
                  <Typography variant="h5" color="primary">
                    {info.count}
                  </Typography>
                  <Typography variant="body2" color="textSecondary">
                    {info.percentage}
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
          ))}
        </Grid>
      </>
    );
  }

  // REGION VIEW: Location-Wise line chart of rejection counts
  const locations = Array.from(new Set(
    rawAlarms
      .filter(a => a.Region === filters.region)
      .map(a => a.Location)
  ));

  const rejectionTypes = Object.keys(summary.rejectionTypeWise);

  // Build one dataset per rejection type
  const datasets = rejectionTypes.map((type, idx) => {
    const data = locations.map(loc =>
      rawAlarms.filter(a =>
        a.Region === filters.region &&
        a.Location === loc &&
        a.Rejection === type
      ).length
    );
    const color = REJECTION_COLORS[idx % REJECTION_COLORS.length];
    return {
      label: type,
      data,
      borderColor: color,
      backgroundColor: color.replace(')', ',0.2)'),
      fill: false,
      tension: 0.4,
      pointRadius: 4
    };
  });

  return (
    <Grid container spacing={2}>
      <Grid item xs={12}>
        <Card>
          <CardContent>
            <Typography variant="h6" gutterBottom>
              Rejection Types by Location in {filters.region}
            </Typography>

            {/* Legend */}
            <Box sx={{ display: 'flex', flexWrap: 'wrap', mb: 2 }}>
              {datasets.map(ds => (
                <Box key={ds.label} sx={{ display: 'flex', alignItems: 'center', mr: 3, mb: 1 }}>
                  <Box sx={{
                    width: 12, height: 12,
                    backgroundColor: ds.borderColor,
                    borderRadius: '50%', mr: 0.5
                  }} />
                  <Typography variant="body2">{ds.label}</Typography>
                </Box>
              ))}
            </Box>

            <MyChart
              type="line"
              data={{ labels: locations, datasets }}
              options={{
                scales: {
                  x: { title: { display: true, text: 'Location' } },
                  y: { title: { display: true, text: 'Count of Alarms' } }
                }
              }}
              height={360}
            />
          </CardContent>
        </Card>
      </Grid>
    </Grid>
  );
}





I want to modify some files there is There is no need to seprate Rejection Type Wise pie chart.
use rejection type wise count and percentage When display Global summary display percentage for Every region block.
ex. when i slect region Global. Then pie chart are spread like .... EMEA, APAC, LACA, NAMER 
then display percentage for rejection types or display only Priority Wise percentage for specific region
.
also When i select specific region  then display Rejection Type Wise count and percentage in Location Wise line chart format.make in your openion 
i want display more attractive .


Adjust files as per my request and give me updated js files carefully.

File 1
AlarmCards.js



import React from 'react';
import { Card, CardContent, Typography, Grid } from '@mui/material';

export default function AlarmCard({ summary }) {
  if (!summary) return null;

  return (
    <Grid container spacing={2} sx={{ mb: 3 }}>
      <Grid item xs={12} sm={6} md={3}>
        <Card>
          <CardContent>
            <Typography variant="subtitle1" gutterBottom>
              Total Alarms
            </Typography>
            <Typography variant="h4">
              {summary.totalAlarms}
            </Typography>
          </CardContent>
        </Card>
      </Grid>
      <Grid item xs={12} sm={6} md={3}>
        <Card>
          <CardContent>
            <Typography variant="subtitle1" gutterBottom>
              Response Sent %
            </Typography>
            <Typography variant="h4">
              {summary.responseSentPercentage}
            </Typography>
          </CardContent>
        </Card>
      </Grid>
    </Grid>
  );
}



File 2

Chart.js



import React, { useEffect, useRef } from 'react';
import Chart from 'chart.js/auto';

export default function MyChart({
  type = 'bar',
  data,
  options = {},
  width = '100%',
  height = 400
}) {
  const canvasRef = useRef(null);
  const chartRef  = useRef(null);

  useEffect(() => {
    if (!canvasRef.current) return;
    const ctx = canvasRef.current.getContext('2d');
    if (chartRef.current) chartRef.current.destroy();

    // Build dataset with line-chart specifics if needed
    const ds = {
      label: data.label || '',
      data: data.values,
      backgroundColor: data.bgColors,
      borderColor: data.borderColor,
      borderWidth: 2,
      fill: type === 'line' ? false : true,
      tension: type === 'line' ? 0.4 : 0,
      pointBackgroundColor: data.borderColor,
      pointRadius: type === 'line' ? 4 : undefined,
    };

    chartRef.current = new Chart(ctx, {
      type,
      data: {
        labels: data.labels,
        datasets: [ds],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        ...options,
      }
    });

    return () => chartRef.current && chartRef.current.destroy();
  }, [type, data, options]);

  return (
    <div style={{ width, height }}>
      <canvas ref={canvasRef} />
    </div>
  );
}


File 3
Chart.js

import React from 'react';
import { TextField, MenuItem } from '@mui/material';

const Filters = ({
  filters,
  setFilters,
  regionOptions = [],
  locationOptions = []
}) => {
  const handleChange = (field) => (e) =>
    setFilters(prev => ({
      ...prev,
      [field]: e.target.value,
      ...(field === 'region' && { location: '' })
    }));

  return (
    <div style={{ display: 'flex', gap: '1rem', marginBottom: 16 }}>
      <TextField
        select
        label="Region"
        value={filters.region}
        onChange={handleChange('region')}
        style={{ minWidth: 150 }}
      >
        <MenuItem value="">Global</MenuItem>
        {regionOptions.map(region => (
          <MenuItem key={region} value={region}>
            {region}
          </MenuItem>
        ))}
      </TextField>

      {filters.region && (
        <TextField
          select
          label="Location"
          value={filters.location}
          onChange={handleChange('location')}
          style={{ minWidth: 200 }}
        >
          <MenuItem value="">All Locations</MenuItem>
          {locationOptions.map(loc => (
            <MenuItem key={loc} value={loc}>
              {loc}
            </MenuItem>
          ))}
        </TextField>
      )}
    </div>
  );
};

export default Filters;




File 4

SummaryCard.js




// src/components/SummaryCards.js
import React from 'react';
import './SummaryCards.css';
import MyChart from './Chart';
import { Card, CardContent, Typography, Grid, Box } from '@mui/material';

// Default palette (for non-priority, non-month, non-location)
const DEFAULT_COLORS = [
  '#007bff', '#28a745', '#ffc107',
  '#dc3545', '#6f42c1', '#17a2b8',
  '#fd7e14', '#20c997', '#6c757d',
  '#6610f2',
];

// Priority palette
const PRIORITY_COLORS = {
  Low: '#90ee90',
  Medium: '#ffff00',
  High: '#ff0000',
};

export default function SummaryCards({ summary, filters }) {
  if (!summary) return null;

  // Build data for any key
  const makeData = (key, obj) => {
    let labels = Object.keys(obj);

    // Sort months chronologically
    if (key === 'monthWise') {
      labels = labels.sort((a,b) => {
        const [mA,yA]=a.split('-').map(Number),
              [mB,yB]=b.split('-').map(Number);
        return new Date(yA,mA-1) - new Date(yB,mB-1);
      });
    }

    const values = labels.map(lbl => obj[lbl].count);

    let bg, borderColor;
    if (key === 'priorityWise') {
      bg = labels.map(lbl => PRIORITY_COLORS[lbl] || '#ccc');
      borderColor = bg;
    } else if (key === 'monthWise') {
      bg = labels.map(() => 'rgba(0,123,255,0.2)');
      borderColor = '#007bff';
    } else if (key === 'locationWise') {
      // one colour per location
      bg = labels.map((_,i) => DEFAULT_COLORS[i % DEFAULT_COLORS.length]);
      borderColor = bg;
    } else {
      bg = labels.map((_,i) => DEFAULT_COLORS[i % DEFAULT_COLORS.length]);
      borderColor = bg;
    }

    return { labels, values, bgColors: bg, borderColor };
  };

  // Partition data
  const partitionObj = filters.region
    ? { [filters.region]: summary.regionWise[filters.region] }
    : summary.regionWise;

  // Chart configs
  const configs = [
    { key: 'partition',        title: !filters.region ? 'Global Partition' : `${filters.region} Partition`, type: 'doughnut', dataObj: partitionObj },
    filters.region && { key: 'locationWise', title: 'Location Wise', type: 'line', dataObj: summary.locationWise },
    { key: 'rejectionTypeWise',title: 'Rejection Type Wise', type: 'pie',      dataObj: summary.rejectionTypeWise },
     { key: 'priorityWise',     title: 'Priority Wise',      type: 'pie',      dataObj: summary.priorityWise },
     { key: 'operatorWise',     title: 'Operator Wise',      type: 'bar',      dataObj: summary.operatorWise },
    { key: 'monthWise',        title: 'Month Wise',         type: 'line',     dataObj: summary.monthWise }

    // filters.region && { key: 'locationWise', title: 'Location Wise', type: 'line', dataObj: summary.locationWise }

  ].filter(Boolean);

  return (
    <Grid container spacing={2}>
      {configs.map(({ key, title, type, dataObj }) => {
        if (!dataObj || Object.keys(dataObj).length === 0) return null;

        const { labels, values, bgColors, borderColor } = makeData(key, dataObj);

        // Custom options for line charts
        const options = (key === 'monthWise' || key === 'locationWise') ? {
          scales: {
            x: { title: { display: true, text: key === 'monthWise' ? 'Month' : 'Location' } },
            y: { title: { display: true, text: 'Alarm Count' } }
          }
        } : {};

        return (
          <Grid item xs={12} md={4} key={key}>
            <Card>
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  {title}
                </Typography>

                {/* Legend for locationWise */}
                {key === 'locationWise' && (
                  <Box sx={{ display: 'flex', flexWrap: 'wrap', mb: 1 }}>
                    {labels.map((loc, i) => (
                      <Box key={loc} sx={{ display: 'flex', alignItems: 'center', mr: 2, mb: 1 }}>
                        <Box sx={{
                          width: 12, height: 12,
                          backgroundColor: bgColors[i],
                          borderRadius: '50%', mr: 0.5
                        }} />
                        <Typography variant="body2">{loc}</Typography>
                      </Box>
                    ))}
                  </Box>
                )}

                <MyChart
                  type={type}
                  data={{ labels, values, bgColors, borderColor }}
                  options={options}
                  height={260}
                />
              </CardContent>
            </Card>
          </Grid>
        );
      })}
    </Grid>
  );
}


File 5

dashboard.js





// src/pages/Dashboard.js
import React, { useEffect, useState, useMemo, useRef } from 'react';
import { Container, Typography } from '@mui/material';
import Filters      from '../components/Filters';
import SummaryCards from '../components/SummaryCards';
import AlarmCard    from '../components/AlarmCard';
import { getAlarmSummary, getRawAlarms } from '../services/api';

export default function Dashboard() {
  const [summary, setSummary]     = useState(null);
  const [rawAlarms, setRawAlarms] = useState([]);
  const [filters, setFilters]     = useState({ region: '', location: '' });

  // 1) Fetch data once
  useEffect(() => {
    Promise.all([ getAlarmSummary(), getRawAlarms() ])
      .then(([sumRes, rawRes]) => {
        setSummary(sumRes.data);
        setRawAlarms(rawRes.data);
      })
      .catch(console.error);
  }, []);

  // 2) Memoize regionOptions so it only changes when summary changes
  const regionOptions = useMemo(() => {
    return summary ? Object.keys(summary.regionWise) : [];
  }, [summary]);

  // 3) Build a map of region → [locations], memoized on rawAlarms and regionOptions
  const regionLocationsMap = useMemo(() => {
    const map = {};
    regionOptions.forEach(region => {
      map[region] = Array.from(
        new Set(
          rawAlarms
            .filter(a => a.Region === region)
            .map(a => a.Location)
        )
      );
    });
    return map;
  }, [rawAlarms, regionOptions]);

  // 4) Build and start slideshow as soon as summary is available
  const slidesRef = useRef([]);
  const slideIdx  = useRef(0);

  useEffect(() => {
    if (!summary) return;   // wait for data

  
    const slides = [{ region: '', location: '' }];
       regionOptions.forEach(region => {
         slides.push({ region, location: '' });
       });

    slidesRef.current = slides;
    slideIdx.current = 0;

    // Immediately show “Global”
    setFilters(slides[0]);

    // Every 60s, advance to the next slide
    const intervalId = setInterval(() => {
      slideIdx.current = (slideIdx.current + 1) % slidesRef.current.length;
      setFilters(slidesRef.current[slideIdx.current]);
    }, 30_000);

    return () => clearInterval(intervalId);
  }, [summary, regionOptions, regionLocationsMap]);

  // 5) Compute filteredSummary exactly as before
  const filteredSummary = useMemo(() => {
    if (!summary) return null;
    const fs = { ...summary };
    if (filters.region) {
      fs.regionWise   = { [filters.region]: summary.regionWise[filters.region] };
      fs.locationWise = {};
      (regionLocationsMap[filters.region] || [])
        .filter(loc => !filters.location || loc === filters.location)
        .forEach(loc => {
          fs.locationWise[loc] = summary.locationWise[loc];
        });
    }
    return fs;
  }, [summary, filters, regionLocationsMap]);

  // 6) Render
  if (!summary) {
    return <Typography>Loading dashboard…</Typography>;
  }

  return (
    <Container sx={{ py: 4 }}>
      <Typography variant="h4" gutterBottom>
        Alarm Analysis Dashboard
      </Typography>

      <Filters
        filters={filters}
        setFilters={setFilters}
        regionOptions={regionOptions}
        locationOptions={filters.region ? regionLocationsMap[filters.region] : []}
      />

      <AlarmCard summary={summary} />

      <SummaryCards
        summary={filteredSummary}
        filters={filters}
        
      />
    </Container>
  );
}





