


import React, { useEffect, useState, useMemo, useRef } from 'react';
import { Box, Typography, Container } from '@mui/material';
import DashboardIcon from '@mui/icons-material/Dashboard';
import Filters from '../components/Filters';
import AlarmCard from '../components/AlarmCard';
import SummaryCards from '../components/SummaryCards';
import { getAlarmSummary, getRawAlarms } from '../services/api';
import { Link } from 'react-router-dom';

export default function Dashboard() {
  const [summary, setSummary] = useState(null);
  const [rawAlarms, setRawAlarms] = useState([]);
  const [filters, setFilters] = useState({
    region: '', location: '', month: '', priority: ''
  });

  useEffect(() => {
    Promise.all([getAlarmSummary(), getRawAlarms()])
      .then(([sumRes, rawRes]) => {
        setSummary(sumRes.data);
        setRawAlarms(rawRes.data);
      })
      .catch(console.error);
  }, []);

  // 1) options
  const regionOptions = useMemo(
    () => summary ? Object.keys(summary.regionWise) : [], [summary]
  );
  const locationOptions = useMemo(
    () => filters.region
      ? Array.from(new Set(
          rawAlarms.filter(a => a.Region === filters.region).map(a => a.Location)
        ))
      : [], [rawAlarms, filters.region]
  );
  const monthOptions = useMemo(
    () => Array.from(new Set(
          rawAlarms
            .filter(a => (!filters.region || a.Region === filters.region) &&
                         (!filters.location || a.Location === filters.location))
            .map(a => a.Month)
        ))
        .sort((a,b)=> a.localeCompare(b)),
    [rawAlarms, filters.region, filters.location]
  );
  const priorityOptions = useMemo(
    () => Array.from(new Set(rawAlarms.map(a => a['CCURE Incident Priority']))),
    [rawAlarms]
  );

  // 2) filtered base for cards & charts
  const filtered = useMemo(() => {
    return rawAlarms.filter(a => {
      if (filters.region && a.Region !== filters.region) return false;
      if (filters.location && a.Location !== filters.location) return false;
      if (filters.month && a.Month !== filters.month) return false;
      if (filters.priority && a['CCURE Incident Priority'] !== filters.priority) return false;
      return true;
    });
  }, [rawAlarms, filters]);

  // 3) summary slice for cards/charts
  const filteredSummary = useMemo(() => {
    if (!summary) return null;
    // keep rejectionTypeWise, then overwrite regionWise/monthWise/locationWise/operatorWise
    const fs = { ...summary };

    // regionWise & locationWise
    if (filters.region) {
      fs.regionWise = { [filters.region]: summary.regionWise[filters.region] };
      fs.locationWise = {};
      locationOptions
        .filter(l => !filters.location || l === filters.location)
        .forEach(l => {
          fs.locationWise[l] = summary.locationWise[l];
        });
    }

    // monthWise
    if (filters.month) {
      const mCount = filtered.filter(a => a.Month === filters.month).length;
      fs.monthWise = { [filters.month]: { count: mCount } };
    } else {
      fs.monthWise = {}; // we’ll build from filtered raw
    }

    // operatorWise
    const opCounts = filtered.reduce((c,a)=>{
      const op = a['Name of Person Attending Alarms (First, Last Name)']||'Unknown';
      c[op] = (c[op]||0) + 1;
      return c;
    }, {});
    fs.operatorWise = Object.fromEntries(
      Object.entries(opCounts).map(([k,v])=>[k,{count:v}])
    );

    return fs;
  }, [summary, filtered, filters, locationOptions]);

  if (!summary) return <Typography>Loading dashboard…</Typography>;

  return (
    <Box sx={{ width:'100vw', minHeight:'100vh', overflowX:'hidden' }}>
      <Box component="header" sx={{
        display:'flex', alignItems:'center', justifyContent:'space-between',
        borderBottom:'3px solid #1976d2', bgcolor:'#e3f2fd', p:2
      }}>
        <Box sx={{ display:'flex', alignItems:'center', gap:1 }}>
          <DashboardIcon fontSize="large" /><Typography variant="h4">Alarm Analysis Dashboard</Typography>
        </Box>
        <Box sx={{ display:'flex', gap:2 }}>
          <Link to="/">➤ Dashboard</Link><Link to="/alarms">➤ Raw Alarms</Link>
        </Box>
      </Box>

      <Container maxWidth={false} sx={{ py:4 }}>
        <Filters
          filters={filters} setFilters={setFilters}
          regionOptions={regionOptions}
          locationOptions={locationOptions}
          monthOptions={monthOptions}
          priorityOptions={priorityOptions}
        />

        {/* cards (top row) */}
        <AlarmCard
          summary={filteredSummary}
          rawAlarms={rawAlarms}
          filters={filters}
        />

        {/* charts */}
        <SummaryCards
          summary={filteredSummary}
          filters={filters}
          rawAlarms={filtered}
        />
      </Container>
    </Box>
  );
}





import React from 'react';
import MyChart from './Chart';
import { Card, CardContent, Typography, Grid } from '@mui/material';

// … your color constants unchanged …

export default function SummaryCards({ summary, filters, rawAlarms }) {
  if (!summary) return null;

  const {
    rejectionTypeWise = {},
    regionWise = {},
    monthWise = {},
    locationWise = {},
    operatorWise = {}
  } = summary;

  // 1) Rejection stats (unchanged) …

  // 2) Use rawAlarms (already filtered) for month chart:
  const monthLabels = Object.keys(monthWise);
  const monthValues = monthLabels.map(m => monthWise[m].count || 0);
  const monthColors = defaultColors.slice(0, monthLabels.length);

  // 3) The rest (partition, priority, operator) all use the
  // same `rawAlarms` slice passed from Dashboard above.

  return (
    <>
      {/* Rejection-Type Cards */}  
      {/* … */}

      {/* Partition / Priority / Location charts */}
      {/* … */}

      {/* Month / Operator */}
      <Grid container spacing={5}>
        {monthLabels.length > 0 && (
          <Grid item xs={12} md={6}>
            <Card sx={{ border:'1px solid #ccc', boxShadow:3 }}>
              <CardContent>
                <Typography variant="h6" gutterBottom>Month Wise</Typography>
                <MyChart
                  type="line"
                  data={{ labels: monthLabels, values: monthValues, bgColors: monthColors, borderColor: monthColors }}
                  options={{
                    animation: { duration: 1000, easing: 'easeOutQuart' },
                    scales: {
                      x: { title:{ display:true, text:'Month' } },
                      y: { title:{ display:true, text:'Alarm Count' } }
                    }
                  }}
                  height={400}
                  width={'100%'}
                />
              </CardContent>
            </Card>
          </Grid>
        )}
        {/* Operator chart */}
        {/* … */}
      </Grid>
    </>
  );
}





import React, { useEffect, useState, useMemo } from 'react';
import {
  Typography, Container, Box,
  Grid, Button, Link as RouterLink
} from '@mui/material';
import DashboardIcon from '@mui/icons-material/Dashboard';
import TableChartIcon from '@mui/icons-material/TableChart';
import ListAltIcon from '@mui/icons-material/ListAlt';
import Filters from '../components/Filters';
import AlarmsTable from '../components/AlarmsTable';
import { getRawAlarms } from '../services/api';

export default function RawAlarms() {
  const [alarms, setAlarms] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filters, setFilters] = useState({
    region:'', location:'', door:'', employee:'',
    priority:'', rejection:'', date:''
  });
  const [view, setView] = useState('employee');

  useEffect(() => {
    getRawAlarms()
      .then(res => setAlarms(res.data || []))
      .catch(() => setAlarms([]))
      .finally(() => setLoading(false));
  }, []);

  // filter options cascade
  const regionOptions = useMemo(()=>
    [...new Set(alarms.map(a=>a.Region))].sort(), [alarms]
  );
  const locationOptions = useMemo(()=>
    [...new Set(alarms.filter(a=>!filters.region||a.Region===filters.region)
                    .map(a=>a.Location))].sort(),
    [alarms, filters.region]
  );
  const doorOptions = useMemo(()=>
    [...new Set(alarms
      .filter(a=>(!filters.region||a.Region===filters.region)&&
                   (!filters.location||a.Location===filters.location))
      .map(a=>a.Door)
    )].sort(),
    [alarms, filters.region, filters.location]
  );
  const employeeOptions = useMemo(()=>
    [...new Set(alarms
      .filter(a=>(!filters.region||a.Region===filters.region)&&
                   (!filters.location||a.Location===filters.location))
      .map(a=>a['Employee Name'])
    )].sort(),
    [alarms, filters.region, filters.location]
  );
  const priorityOptions = useMemo(()=>
    [...new Set(alarms.map(a=>a['CCURE Incident Priority']))].sort(),
    [alarms]
  );
  const rejectionOptions = useMemo(()=>
    [...new Set(alarms.map(a=>a.Rejection))].sort(),
    [alarms]
  );

  // full filtered slice
  const filtered = useMemo(()=> alarms.filter(a=>{
    if(filters.region && a.Region!==filters.region) return false;
    if(filters.location && a.Location!==filters.location) return false;
    if(filters.door && a.Door!==filters.door) return false;
    if(filters.employee && a['Employee Name']!==filters.employee) return false;
    if(filters.priority && a['CCURE Incident Priority']!==filters.priority) return false;
    if(filters.rejection && a.Rejection!==filters.rejection) return false;
    if(filters.date && a.Date!==filters.date) return false;
    return true;
  }), [alarms, filters]);

  if(loading) {
    return (
      <Container maxWidth={false} sx={{ pt:4 }}>
        <Typography variant="h4">Raw Alarms Analysis</Typography>
        <Typography>Loading…</Typography>
      </Container>
    );
  }

  return (
    <Container maxWidth={false} sx={{ p:0, height:'100vh', overflow:'auto' }}>
      {/* header */}
      <Box sx={{
        display:'flex', alignItems:'center', justifyContent:'space-between',
        bgcolor:'background.paper', p:2, borderBottom:1, borderColor:'divider'
      }}>
        <Box sx={{ display:'flex', alignItems:'center', gap:1 }}>
          <TableChartIcon fontSize="large" />
          <Typography variant="h4">Raw Alarms Analysis</Typography>
        </Box>
        <Box sx={{ display:'flex', gap:2 }}>
          <RouterLink to="/"><DashboardIcon /> Dashboard</RouterLink>
          <RouterLink to="/alarms"><TableChartIcon /> Raw Alarms</RouterLink>
        </Box>
      </Box>

      {/* filters */}
      <Box sx={{ p:2 }}>
        <Filters
          filters={filters} setFilters={setFilters}
          regionOptions={regionOptions}
          locationOptions={locationOptions}
          doorOptions={doorOptions}
          employeeOptions={employeeOptions}
          priorityOptions={priorityOptions}
          rejectionOptions={rejectionOptions}
        />
      </Box>

      {/* view toggle */}
      <Box sx={{ p:2, display:'flex', gap:2 }}>
        <Button
          variant={view==='employee'?'contained':'outlined'}
          onClick={()=>setView('employee')}
        >
          Employee Analysis
        </Button>
        <Button
          variant={view==='door'?'contained':'outlined'}
          onClick={()=>setView('door')}
        >
          Door Analysis
        </Button>
        <Button
          variant={view==='detailed'?'contained':'outlined'}
          onClick={()=>setView('detailed')}
        >
          Detailed Records
        </Button>
      </Box>

      {/* table */}
      <Box sx={{ p:2 }}>
        <AlarmsTable alarms={filtered} maxRows={50} tableType={view} />
      </Box>
    </Container>
  );
}












Read Carefully Below All js files .And see Month Wise Dropdown is added on dashboard page
but When i try to filter data on monthly All charts and its value are not updates yet.

same issue for raw alarms page.Read all files carefully and solve this issue.

Important- add export option for raw alarms in every section .add export option 
Employee analysis as Well Door Analysis . details Records already have this option.

and Add more dynamic Effects on charts , add animations, add Borders, and more colours 
make icons colourful .

dont change any another functiomn

read carefully all below files carefully and give me Updated js files

File 1

AlarmCard.js


import React from 'react';
import { Card, CardContent, Typography, Grid } from '@mui/material';

export default function AlarmCard({ summary, rawAlarms, filters }) {
  if (!summary) return null;

  // apply all filters (region, location, month) to raw alarms
  const filtered = rawAlarms.filter(a => {
    if (filters.region && a.Region !== filters.region) return false;
    if (filters.location && a.Location !== filters.location) return false;
    if (filters.month && a.Month !== filters.month) return false;
    return true;
  });

  const totalAlarms = filtered.length;
  const sentCount = filtered.filter(a =>
    a['Action Taken'] && a['Action Taken'] !== 'Not Sent'
  ).length;
  const responseSentPercentage = totalAlarms
    ? `${((sentCount / totalAlarms) * 100).toFixed(2)}%`
    : '0%';

  return (
    <Grid container spacing={2} sx={{ mb: 3 }}>
      {/* Total Alarms */}
      <Grid item xs={12} sm={6} md={3}>
        <Card>
          <CardContent>
            <Typography variant="subtitle1" gutterBottom>
              Total Alarms
            </Typography>
            <Typography variant="h4">{totalAlarms}</Typography>
          </CardContent>
        </Card>
      </Grid>

      {/* Response Sent % */}
      <Grid item xs={12} sm={6} md={3}>
        <Card>
          <CardContent>
            <Typography variant="subtitle1" gutterBottom>
              Response Sent %
            </Typography>
            <Typography variant="h4">{responseSentPercentage}</Typography>
          </CardContent>
        </Card>
      </Grid>
    </Grid>
  );
}



File 2

Alarmstable.js



// src/components/AlarmsTable.js
import React, { useMemo } from 'react';
import { DataGrid } from '@mui/x-data-grid';
import { Button, Typography } from '@mui/material';
import * as XLSX from 'xlsx';

const AlarmsTable = ({
  alarms = [],
  maxRows = 10,
  tableType = 'employee'
}) => {
  // Excel export
  const exportToExcel = () => {
    const ws = XLSX.utils.json_to_sheet(alarms);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Alarms');
    XLSX.writeFile(wb, 'alarms.xlsx');
  };

  // 1) Employee stats with lastAction
  const employeeStats = useMemo(() => {
    const stats = {};
    alarms.forEach(a => {
      const emp = a['Employee Name'] || 'Unknown';
      const dt = a.Date + ' ' + a['Time of  Alarm (Local time)'];
      if (!stats[emp]) {
        stats[emp] = {
          total: 0,
          types: new Set(),
          doorRej: {},
          lastDt: dt,
          lastRegion: a.Region,
          lastLocation: a.Location,
          lastAction: a['Action Taken']
        };
      }
      const e = stats[emp];
      e.total += 1;
      e.types.add(a.Rejection);
      const drKey = `${a.Door}::${a.Rejection}`;
      e.doorRej[drKey] = (e.doorRej[drKey] || 0) + 1;
      if (dt > e.lastDt) {
        e.lastDt = dt;
        e.lastRegion = a.Region;
        e.lastLocation = a.Location;
        e.lastAction = a['Action Taken'];
      }
    });

    return Object.entries(stats).map(([emp, s], idx) => {
      const repeats = Object.entries(s.doorRej).filter(([, c]) => c > 1);
      let topDoor = '', topCount = 0;
      if (repeats.length) {
        const [key, cnt] = repeats.reduce((a, b) => a[1] > b[1] ? a : b);
        [topDoor] = key.split('::');
        topCount = cnt;
      }
      const [lastDate, lastTime] = s.lastDt.split(' ');
      return {
        id: idx,
        srNo: idx + 1,
        lastDate,
        lastTime,
        location: s.lastLocation,
        region: s.lastRegion,
        employee: emp,
        lastAction: s.lastAction,
        total: s.total,
        repeatedDoor: topDoor,
        repeatCount: topCount,
        rejectionTypes: Array.from(s.types).join(', ')
      };
    });
  }, [alarms]);

  // 2) Door stats
  const doorStats = useMemo(() => {
    const d = {};
    alarms.forEach(a => {
      const door = a.Door || 'Unknown';
      if (!d[door]) d[door] = { total: 0, rejections: {} };
      d[door].total += 1;
      d[door].rejections[a.Rejection] = (d[door].rejections[a.Rejection]||0) + 1;
    });
    return Object.entries(d)
      .filter(([, s]) => s.total > 1)
      .map(([door, s], idx) => ({
        id: idx,
        door,
        total: s.total,
        rejectionCounts: Object.entries(s.rejections)
          .map(([t,c]) => `${t}:${c}`)
          .join(', ')
      }));
  }, [alarms]);

  // 3) Detailed raw rows
  const rawRows = useMemo(() => alarms.map((a,i) => ({ id: i, ...a })), [alarms]);

  if (!alarms.length) {
    return (
      <Typography variant="h6" align="center" sx={{ mt: 4 }}>
        No alarm records to display.
      </Typography>
    );
  }

  // Columns for each table
  const empColumns = [
    { field: 'srNo', headerName: 'Sr. No', width: 80 },
    { field: 'lastDate', headerName: 'Date', width: 120 },
    { field: 'lastTime', headerName: 'Time', width: 120 },
    { field: 'location', headerName: 'Location', width: 150 },
    { field: 'region', headerName: 'Region', width: 120 },
    { field: 'employee', headerName: 'Employee Name', width: 180 },
    { field: 'lastAction', headerName: 'Action Taken', width: 180 },
    { field: 'total', headerName: 'Total Alarms', width: 130 },
    { field: 'repeatedDoor', headerName: 'Repeated Door', width: 200 },
    { field: 'repeatCount', headerName: 'Repeat Count', width: 130 },
    { field: 'rejectionTypes', headerName: 'Types of Rejection', width: 300 },
  ];

  const doorColumns = [
    { field: 'door', headerName: 'Door', width: 300 },
    { field: 'total', headerName: 'Total Alarms', width: 150 },
    { field: 'rejectionCounts', headerName: 'Rejection Counts', width: 400 }
  ];

  const rawColumns = [
    { field: 'Sr. No', headerName: 'Sr. No', width: 90 },
    { field: 'Date', headerName: 'Date', width: 120 },
    { field: 'Time of  Alarm (Local time)', headerName: 'Time', width: 150 },
    { field: 'Type of Alarm', headerName: 'Type', width: 150 },
    { field: 'Door', headerName: 'Door', width: 250 },
    { field: 'Location', headerName: 'Location', width: 150 },
    { field: 'Region', headerName: 'Region', width: 120 },
    { field: 'Rejection', headerName: 'Rejection', width: 180 },
    { field: 'CCURE Incident Priority', headerName: 'Priority', width: 150 },
    {
      field: 'Name of Person Attending Alarms (First, Last Name)',
      headerName: 'Operator', width: 200
    },
    { field: 'Action Taken', headerName: 'Action Taken', width: 150 },
    { field: ' Time Taken (Min)', headerName: 'Time Taken (Min)', width: 150 }
  ];

  return (
    <div style={{ width: '100%', height: '100%' }}>
      {tableType === 'employee' && (
        <DataGrid
          rows={employeeStats}
          columns={empColumns}
          pageSize={maxRows}
          rowsPerPageOptions={[maxRows]}
          autoHeight={false}
        />
      )}

      {tableType === 'door' && (
        <DataGrid
          rows={doorStats}
          columns={doorColumns}
          pageSize={Math.min(5, maxRows)}
          rowsPerPageOptions={[Math.min(5, maxRows)]}
          autoHeight={false}
        />
      )}

      {tableType === 'detailed' && (
        <>
          <Button variant="contained" color="primary" onClick={exportToExcel} sx={{ mb: 2 }}>
            Export to Excel
          </Button>
          <DataGrid
            rows={rawRows}
            columns={rawColumns}
            getRowClassName={params =>
              params.row[' Time Taken (Min)'] > 0 ? 'sla-breach' : ''
            }
            pageSize={maxRows}
            rowsPerPageOptions={[10, 20, 50].filter(x => x <= rawRows.length)}
            autoHeight={false}
          />
        </>
      )}
    </div>
  );
};

export default AlarmsTable;



File 3

Chart.js


import React, { useEffect, useRef } from 'react';
import Chart from 'chart.js/auto';

// stronger, fixed palette
const defaultColors = [
  '#3366CC', '#DC3912', '#FF9900', '#109618',
  '#990099', '#0099C6', '#DD4477', '#66AA00',
  '#B82E2E', '#316395'
];

export default function MyChart({
  type = 'bar',
  data,
  options = {},
  width = '100%',
  height = '100%'
}) {
  const canvasRef = useRef(null);
  const chartRef  = useRef(null);

  useEffect(() => {
    if (!canvasRef.current) return;
    const ctx = canvasRef.current.getContext('2d');
    if (chartRef.current) chartRef.current.destroy();

    const bg = data.bgColors || defaultColors.slice(0, data.values.length);
    const border = data.borderColor || bg;

    const chartData = {
      labels: data.labels,
      datasets: [{
        label: data.label || '',
        data: data.values,
        backgroundColor: bg,
        borderColor: border,
        borderWidth: 2,
        ...(type === 'line' && {
          tension: 0.3,
          pointRadius: 6
        })
      }],
    };

    chartRef.current = new Chart(ctx, {
      type,
      data: chartData,
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: { duration: 800 },
        plugins: {
          legend: { labels: { font: { size: 14 } } }
        },
        scales: {
          x: { beginAtZero: true, ...(options.scales?.x || {}) },
          y: { beginAtZero: true, ...(options.scales?.y || {}) }
        },
        ...options
      },
    });

    return () => chartRef.current?.destroy();
  }, [type, data, options]);

  return (
    <div style={{ width, height, border: '1px solid #ccc', borderRadius: 4, padding: 8 }}>
      <canvas ref={canvasRef} />
    </div>
  );
}




Filters.js


// src/components/Filters.js
import React from 'react';
import {
  TextField,
  MenuItem,
  Grid,
  InputAdornment
} from '@mui/material';
import PublicIcon from '@mui/icons-material/Public';
import LocationOnIcon from '@mui/icons-material/LocationOn';
import CalendarMonthIcon from '@mui/icons-material/CalendarMonth';
import SearchIcon from '@mui/icons-material/Search';
import PriorityHighIcon from '@mui/icons-material/PriorityHigh';

export default function Filters({
  filters,
  setFilters,
  regionOptions = [],
  locationOptions = [],
  monthOptions,
  employeeOptions,
  doorOptions,
  priorityOptions,
  rejectionOptions
}) {
  const handleChange = field => e => {
    const value = e.target.value;
    setFilters(prev => {
      const next = { ...prev, [field]: value };
      // cascade resets
      if (field === 'region') {
        next.location = '';
        next.month = '';
        next.priority = '';
        next.rejection = '';
        next.employee = '';
        next.door = '';
      }
      if (field === 'location') {
        next.month = '';
        next.priority = '';
        next.rejection = '';
        next.employee = '';
        next.door = '';
      }
      if (field === 'month') {
        next.priority = '';
        next.rejection = '';
      }
      if (field === 'priority') {
        next.rejection = '';
      }
      if (field === 'door') {
        next.rejection = '';
      }
      return next;
    });
  };

  return (
    <Grid container spacing={2} alignItems="center" sx={{ mb: 3 }}>
      {/* Region */}
      <Grid item>
        <TextField
          select label="Region" fullWidth
          value={filters.region}
          onChange={handleChange('region')}
          InputProps={{
            startAdornment: <InputAdornment position="start"><PublicIcon/></InputAdornment>
          }}
        >
          <MenuItem key="" value="">All Regions</MenuItem>
          {regionOptions.map(r => (
            <MenuItem key={r} value={r}>{r}</MenuItem>
          ))}
        </TextField>
      </Grid>

      {/* Location */}
      <Grid item>
        <TextField
          select label="Location" fullWidth
          value={filters.location}
          onChange={handleChange('location')}
          disabled={!filters.region}
          InputProps={{
            startAdornment: <InputAdornment position="start"><LocationOnIcon/></InputAdornment>
          }}
        >
          <MenuItem key="" value="">All Locations</MenuItem>
          {locationOptions.map(l => (
            <MenuItem key={l} value={l}>{l}</MenuItem>
          ))}
        </TextField>
      </Grid>

      {/* Month */}
      {monthOptions && (
        <Grid item>
          <TextField
            select label="Month" fullWidth
            value={filters.month}
            onChange={handleChange('month')}
            InputProps={{
              startAdornment: <InputAdornment position="start"><CalendarMonthIcon/></InputAdornment>
            }}
          >
            <MenuItem key="" value="">All Months</MenuItem>
            {monthOptions.map(m => (
              <MenuItem key={m} value={m}>{m}</MenuItem>
            ))}
          </TextField>
        </Grid>
      )}

      {/* Employee */}
      {employeeOptions && (
        <Grid item>
          <TextField
            select label="Employee" fullWidth
            value={filters.employee}
            onChange={handleChange('employee')}
            InputProps={{
              startAdornment: <InputAdornment position="start"><SearchIcon/></InputAdornment>
            }}
          >
            <MenuItem key="" value="">All Employees</MenuItem>
            {employeeOptions.map(e => (
              <MenuItem key={e} value={e}>{e}</MenuItem>
            ))}
          </TextField>
        </Grid>
      )}

      {/* Door */}
      {doorOptions && (
        <Grid item>
          <TextField
            select label="Door" fullWidth
            value={filters.door}
            onChange={handleChange('door')}
          >
            <MenuItem key="" value="">All Doors</MenuItem>
            {doorOptions.map(d => (
              <MenuItem key={d} value={d}>{d}</MenuItem>
            ))}
          </TextField>
        </Grid>
      )}

      {/* Priority */}
      {priorityOptions && (
        <Grid item>
          <TextField
            select label="Priority" fullWidth
            value={filters.priority}
            onChange={handleChange('priority')}
            InputProps={{
              startAdornment: <InputAdornment position="start"><PriorityHighIcon/></InputAdornment>
            }}
          >
            <MenuItem key="" value="">All Priorities</MenuItem>
            {priorityOptions.map(p => (
              <MenuItem key={p} value={p}>{p}</MenuItem>
            ))}
          </TextField>
        </Grid>
      )}

      {/* Rejection */}
      {rejectionOptions && (
        <Grid item>
          <TextField
            select label="Rejection" fullWidth
            value={filters.rejection}
            onChange={handleChange('rejection')}
          >
            <MenuItem key="" value="">All Rejections</MenuItem>
            {rejectionOptions.map(r => (
              <MenuItem key={r} value={r}>{r}</MenuItem>
            ))}
          </TextField>
        </Grid>
      )}

      {/* Date */}
      {filters.hasOwnProperty('date') && (
        <Grid item>
          <TextField
            label="Date"
            type="date"
            fullWidth
            value={filters.date}
            onChange={handleChange('date')}
            InputLabelProps={{ shrink: true }}
          />
        </Grid>
      )}
    </Grid>
  );
}




File 4

Summarycard.js


import React from 'react';
import MyChart from './Chart';
import { Card, CardContent, Typography, Grid } from '@mui/material';

// fixed priority colors
const PRIORITY_COLORS = {
  High: '#DC3912',
  Medium: '#FF9900',
  Low: '#109618'
};

// strong default palette for other charts
const defaultColors = [
  '#FF9900', '#109618', '#FED06A', '#DC3912',
  '#990099', '#0099C6', '#C1D82F', '#66AA00',
  '#3366CC', '#B82E2E', '#316395', '#71C9CD'
];

// unique fallback palette for rejection types (distinct from defaultColors)
const REJECTION_COLORS = [
  '#006400', '#00008B', '#8B008B', '#FF1493',
  '#00CED1', '#2F4F4F', '#6f1c03', '#ff9a00'
];

// explicit mappings for key rejection types
const REJECTION_COLOR_MAP = {
  'Wrong PIN': '#109618',
  'Clearance - Access Violation': '#FEDC56',
  'Expired': '#FF4F00',
  'Disabled Badge': '#ED9121'
};

export default function SummaryCards({ summary, filters, rawAlarms }) {
  if (!summary) return null;

  const {
    rejectionTypeWise = {},
    regionWise = {},
    locationWise = {},
    operatorWise = {}
  } = summary;

  // 1. Rejection Stats (unchanged) …
  function getRejectionStats() {
    let entries;
    if (!filters.region) {
      entries = Object.entries(rejectionTypeWise);
    } else if (!filters.location) {
      const total = regionWise[filters.region]?.count || 0;
      const byType = rawAlarms
        .filter(a => a.Region === filters.region)
        .reduce((acc, a) => {
          acc[a.Rejection] = (acc[a.Rejection] || 0) + 1;
          return acc;
        }, {});
      entries = Object.entries(byType).map(
        ([type, count]) => [type, { count, percentage: total ? `${((count/total)*100).toFixed(2)}%` : '0%' }]
      );
    } else {
      const total = locationWise[filters.location]?.count || 0;
      const byType = rawAlarms
        .filter(a => a.Region === filters.region && a.Location === filters.location)
        .reduce((acc, a) => {
          acc[a.Rejection] = (acc[a.Rejection] || 0) + 1;
          return acc;
        }, {});
      entries = Object.entries(byType).map(
        ([type, count]) => [type, { count, percentage: total ? `${((count/total)*100).toFixed(2)}%` : '0%' }]
      );
    }

    return entries
      .map(([type, info], idx) => ({
        type,
        count: info.count,
        percentage: info.percentage,
        color: REJECTION_COLOR_MAP[type] || REJECTION_COLORS[idx % REJECTION_COLORS.length]
      }))
      .sort((a, b) => b.count - a.count);
  }
  const rejectionStats = getRejectionStats();

  // 2. Filter rawAlarms by region/location/month (unchanged)
  const filtered = rawAlarms.filter(a => {
    if (filters.region && a.Region !== filters.region) return false;
    if (filters.location && a.Location !== filters.location) return false;
    if (filters.month && a.Month !== filters.month) return false;
    return true;
  });

  // 3. Priority Wise (unchanged) …
  const prCounts = filtered.reduce((acc, a) => {
    const p = a['CCURE Incident Priority'];
    acc[p] = (acc[p] || 0) + 1;
    return acc;
  }, {});
  const prLabels = Object.keys(prCounts);
  const prValues = prLabels.map(l => prCounts[l]);
  const prColors = prLabels.map(l => PRIORITY_COLORS[l] || '#999');

  // 4. Operator Wise (unchanged) …
  const opCountsObj = operatorWise || {};
  const opLabels = Object.keys(opCountsObj);
  const opValues = opLabels.map(l => opCountsObj[l].count || 0);
  const opColors = defaultColors.slice(0, opLabels.length);

  // 5. Partition Data (unchanged) …
  const partitionObj = !filters.region
    ? Object.fromEntries(Object.entries(regionWise).map(([r, info]) => [r, info.count || 0]))
    : filtered.reduce((acc, a) => {
        acc[a.Location] = (acc[a.Location] || 0) + 1;
        return acc;
      }, {});
  const partLabels = Object.keys(partitionObj);
  const partValues = partLabels.map(l => partitionObj[l]);
  const partColors = defaultColors.slice(0, partLabels.length);

    const monthCounts = filtered.reduce((acc, a) => {
      // first try a.Month, otherwise extract from a.Date
      const monthKey = a.Month
        || new Date(a.Date).toLocaleString('en-US', { month: 'short' });
      if (!monthKey) return acc;
      acc[monthKey] = (acc[monthKey] || 0) + 1;
        return acc;
      }, {});
      const monthLabels = Object.keys(monthCounts).sort((a, b) => {
        // sort by calendar order
        const monthOrder = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        return monthOrder.indexOf(a) - monthOrder.indexOf(b);
      });
      const monthValues = monthLabels.map(m => monthCounts[m]);
      const monthColors = defaultColors.slice(0, monthLabels.length);
    

  // 7. Location Wise (unchanged) …
  const locLabels = Object.keys(locationWise);
  const locValues = locLabels.map(l => locationWise[l].count || 0);
  const locColors = defaultColors.slice(0, locLabels.length);

  return (
    <>
      {/* Rejection-Type Cards */}
      <Grid container spacing={2} sx={{ mb: 2 }}>
        {rejectionStats.map(({ type, count, percentage, color }) => (
          <Grid item xs={12} sm={6} md={3} key={type}>
            <Card sx={{ border: `2px solid ${color}`, backgroundColor: color, color: '#fff' }}>
              <CardContent>
                <Typography variant="subtitle2">{type}</Typography>
                <Typography variant="h6">{count}</Typography>
                <Typography variant="body2">{percentage}</Typography>
              </CardContent>
            </Card>
          </Grid>
        ))}
      </Grid>

      {/* Partition / Priority / Location */}
      <Grid container spacing={5} sx={{ mb: 4 }}>
        {partLabels.length > 0 && (
          <Grid item xs={400} md={200}>
            <Card sx={{ border: '1px solid #ccc' }}>
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  {!filters.region ? 'Global Partition' : `${filters.region} → Location`}
                </Typography>
                <MyChart
                  type="doughnut"
                  data={{ labels: partLabels, values: partValues, bgColors: partColors, borderColor: partColors }}
                  height={600}
                  width={650}
                />
              </CardContent>
            </Card>
          </Grid>
        )}

        {prLabels.length > 0 && (
          <Grid item xs={400} md={200}>
            <Card sx={{ border: '1px solid #ccc' }}>
              <CardContent>
                <Typography variant="h6" gutterBottom>Priority Wise</Typography>
                <MyChart
                  type="pie"
                  data={{ labels: prLabels, values: prValues, bgColors: prColors, borderColor: prColors }}
                  height={600}
                  width={650}
                />
              </CardContent>
            </Card>
          </Grid>
        )}

        {locLabels.length > 0 && (
          <Grid item xs={400} md={200}>
            <Card sx={{ border: '1px solid #ccc' }}>
              <CardContent>
                <Typography variant="h6" gutterBottom>Location Wise</Typography>
                <MyChart
                  type="line"
                  data={{ labels: locLabels, values: locValues, bgColors: locColors, borderColor: locColors }}
                  options={{
                    scales: {
                      x: { title: { display: true, text: 'Location' } },
                      y: { title: { display: true, text: 'Alarm Count' } }
                    }
                  }}
                  height={600}
                  width={900}
                />
              </CardContent>
            </Card>
          </Grid>
        )}
      </Grid>

      {/* Month / Operator */}
      <Grid container spacing={5}>
        {monthLabels.length > 0 && (
          <Grid item xs={400} md={200}>
            <Card sx={{ border: '1px solid #ccc' }}>
              <CardContent>
                <Typography variant="h6" gutterBottom>Month Wise</Typography>
                <MyChart
                  type="line"
                  data={{
                    labels: monthLabels,
                    values: monthValues,
                    bgColors: monthColors,
                    borderColor: monthColors
                  }}
                  options={{
                    scales: {
                      x: { title: { display: true, text: 'Month' } },
                      y: { title: { display: true, text: 'Alarm Count' } }
                    }
                  }}
                  height={600}
                  width={600}
                />
              </CardContent>
            </Card>
          </Grid>
        )}

        {opLabels.length > 0 && (
          <Grid item xs={400} md={200}>
            <Card sx={{ border: '1px solid #ccc' }}>
              <CardContent>
                <Typography variant="h6" gutterBottom>Operator Wise</Typography>
                <MyChart
                  type="bar"
                  data={{ labels: opLabels, values: opValues, bgColors: opColors, borderColor: opColors }}
                  height={600}
                  width={800}
                />
              </CardContent>
            </Card>
          </Grid>
        )}
      </Grid>
    </>
  );
}



File  5

Dashboard.js


// src/pages/Dashboard.js
import React, { useEffect, useState, useMemo, useRef } from 'react';
import { Box, Typography, Container } from '@mui/material';
import DashboardIcon from '@mui/icons-material/Dashboard';
import Filters      from '../components/Filters';
import SummaryCards from '../components/SummaryCards';
import AlarmCard    from '../components/AlarmCard';
import { getAlarmSummary, getRawAlarms } from '../services/api';
import { Link } from 'react-router-dom';

export default function Dashboard() {
  const [summary, setSummary]     = useState(null);
  const [rawAlarms, setRawAlarms] = useState([]);
  const [filters, setFilters]     = useState({
    region: '', location: '', month: '', priority: ''
  });

  // Fetch summary & raw
  useEffect(() => {
    Promise.all([getAlarmSummary(), getRawAlarms()])
      .then(([s, r]) => {
        setSummary(s.data);
        setRawAlarms(r.data);
      })
      .catch(console.error);
  }, []);

  // Region options
  const regionOptions = useMemo(
    () => summary ? Object.keys(summary.regionWise) : [],
    [summary]
  );

  // Location options depend on region
  const locationOptions = useMemo(
    () => filters.region
      ? Array.from(new Set(
          rawAlarms
            .filter(a => a.Region === filters.region)
            .map(a => a.Location)
        ))
      : [],
    [rawAlarms, filters.region]
  );

  // Month options from summary.monthWise
  const monthOptions = useMemo(
    () => summary ? Object.keys(summary.monthWise).sort() : [],
    [summary]
  );

  // Priority options
  const priorityOptions = useMemo(
    () => Array.from(new Set(
      rawAlarms.map(a => a['CCURE Incident Priority'])
    )),
    [rawAlarms]
  );

  // Compute totals & response %
  const { totalAlarms, responseSentPercentage } = useMemo(() => {
    const base = rawAlarms.filter(a => {
      if (filters.region   && a.Region   !== filters.region)   return false;
      if (filters.location && a.Location !== filters.location) return false;
      if (filters.month    && a.Month    !== filters.month)    return false;
      if (filters.priority && a['CCURE Incident Priority'] !== filters.priority) return false;
      return true;
    });
    const tot  = base.length;
    const sent = base.filter(a =>
      a['Action Taken'] && a['Action Taken'] !== 'Not Sent'
    ).length;
    return {
      totalAlarms: tot,
      responseSentPercentage: tot
        ? `${((sent / tot) * 100).toFixed(2)}%`
        : '0%'
    };
  }, [rawAlarms, filters]);

  // Auto‐rotate filters
  const slidesRef = useRef([]);
  const slideIdx  = useRef(0);
  useEffect(() => {
    if (!summary) return;
    const slides = [{ region:'', location:'', month:'', priority:'' }];
    regionOptions.forEach(r => slides.push({ region:r, location:'', month:'', priority:'' }));
    slidesRef.current = slides;
    slideIdx.current   = 0;
    setFilters(slides[0]);
    const id = setInterval(() => {
      slideIdx.current = (slideIdx.current + 1) % slidesRef.current.length;
      setFilters(slidesRef.current[slideIdx.current]);
    }, 30000);
    return () => clearInterval(id);
  }, [summary, regionOptions]);

  // Build filteredSummary for charts, including operatorWise
  const filteredSummary = useMemo(() => {
    if (!summary) return null;
    const fs = { ...summary };

    // region & location
    if (filters.region) {
      fs.regionWise   = { [filters.region]: summary.regionWise[filters.region] };
      fs.locationWise = {};
      locationOptions
        .filter(loc => !filters.location || loc === filters.location)
        .forEach(loc => {
          fs.locationWise[loc] = summary.locationWise[loc];
        });
    }

    // month
    if (filters.month) {
      fs.monthWise = { [filters.month]: summary.monthWise[filters.month] };
    }

    // recalc operatorWise from the filtered rawAlarms
    const opCounts = rawAlarms
      .filter(a => {
        if (filters.region   && a.Region   !== filters.region)   return false;
        if (filters.location && a.Location !== filters.location) return false;
        if (filters.month    && a.Month    !== filters.month)    return false;
        if (filters.priority && a['CCURE Incident Priority'] !== filters.priority) return false;
        return true;
      })
      .reduce((acc, a) => {
        // use the actual field name for operator:
        const op = a['Name of Person Attending Alarms (First, Last Name)'] || 'Unknown';
        acc[op] = (acc[op] || 0) + 1;
        return acc;
      }, {});

    fs.operatorWise = Object.fromEntries(
      Object.entries(opCounts).map(([k, v]) => [k, { count: v }])
    );

    return fs;
  }, [summary, rawAlarms, filters, locationOptions]);

  if (!summary) {
    return <Typography>Loading dashboard…</Typography>;
  }

  return (
    <Box sx={{ width:'100vw', minHeight:'100vh', overflowX:'hidden' }}>
      {/* Header */}
      <Box component="header" sx={{
        display:'flex', alignItems:'center', justifyContent:'space-between',
        borderBottom:'3px solid #1976d2', bgcolor:'#e3f2fd', p:2
      }}>
        <Box sx={{ display:'flex', alignItems:'center', gap:1 }}>
          <DashboardIcon fontSize="large" />
          <Typography variant="h4">Alarm Analysis Dashboard</Typography>
        </Box>
        <Box sx={{ display:'flex', gap:2 }}>
          <Link to="/">➤ Dashboard</Link>
          <Link to="/alarms">➤ Raw Alarms</Link>
        </Box>
      </Box>

      <Container maxWidth={false} sx={{ py:4 }}>
        {/* Filters */}
        <Filters
          filters={filters}
          setFilters={setFilters}
          regionOptions={regionOptions}
          locationOptions={locationOptions}
          monthOptions={monthOptions}
          priorityOptions={priorityOptions}
        />

        {/* Cards */}
        <AlarmCard
          summary={filteredSummary}
          rawAlarms={rawAlarms}
          filters={filters}
        />

        {/* Charts */}
        <SummaryCards
          summary={filteredSummary}
          filters={filters}
          rawAlarms={rawAlarms}
        />
      </Container>
    </Box>
  );
}



File 6

RawAlarms.js



// src/pages/RawAlarms.js
import React, { useEffect, useState, useMemo } from 'react';
import { Typography, Container, Grid, TextField, MenuItem, Box, Button, Link } from '@mui/material';
import DashboardIcon from '@mui/icons-material/Dashboard';
import TableChartIcon from '@mui/icons-material/TableChart';
import ListAltIcon from '@mui/icons-material/ListAlt';
import Filters from '../components/Filters';
import AlarmsTable from '../components/AlarmsTable';
import { getRawAlarms } from '../services/api';

export default function RawAlarms() {
  const [alarms, setAlarms]       = useState([]);
  const [loading, setLoading]     = useState(true);
  const [filters, setFilters]     = useState({
    region: '', location: '', door: '', employee: '',
    priority: '', rejection: '', date: ''
  });
  const [view, setView] = useState('employee');

  useEffect(() => {
    getRawAlarms()
      .then(res => setAlarms(res.data || []))
      .catch(() => setAlarms([]))
      .finally(() => setLoading(false));
  }, []);

  // derive filter options
  const regionOptions = useMemo(
    () => Array.from(new Set(alarms.map(a => a.Region))).sort(),
    [alarms]
  );

  const locationOptions = useMemo(
    () => Array.from(new Set(
      alarms
        .filter(a => !filters.region || a.Region === filters.region)
        .map(a => a.Location)
    )).sort(),
    [alarms, filters.region]
  );

  const doorOptions = useMemo(
    () => Array.from(new Set(
      alarms
        .filter(a =>
          (!filters.region   || a.Region   === filters.region) &&
          (!filters.location || a.Location === filters.location)
        )
        .map(a => a.Door)
    )).sort(),
    [alarms, filters.region, filters.location]
  );

  // employeeOptions now built from same region+location slice:
  const employeeOptions = useMemo(
    () => Array.from(new Set(
      alarms
        .filter(a =>
          (!filters.region   || a.Region   === filters.region) &&
          (!filters.location || a.Location === filters.location)
        )
        .map(a => a['Employee Name'])
    )).sort(),
    [alarms, filters.region, filters.location]
  );

  const priorityOptions = useMemo(
    () => Array.from(new Set(alarms.map(a => a['CCURE Incident Priority']))).sort(),
    [alarms]
  );

  const rejectionOptions = useMemo(
    () => Array.from(new Set(alarms.map(a => a.Rejection))).sort(),
    [alarms]
  );

  const filtered = useMemo(() => {
    return alarms.filter(a => {
      if (filters.region   && a.Region   !== filters.region)                return false;
      if (filters.location && a.Location !== filters.location)              return false;
      if (filters.door     && a.Door     !== filters.door)                  return false;
      if (filters.employee && a['Employee Name'] !== filters.employee)      return false;
      if (filters.priority && a['CCURE Incident Priority'] !== filters.priority) return false;
      if (filters.rejection && a.Rejection !== filters.rejection)           return false;
      if (filters.date     && a.Date     !== filters.date)                  return false;
      return true;
    });
  }, [alarms, filters]);

  if (loading) return (
    <Container maxWidth={false} sx={{ pt: 4 }}>
      <Typography variant="h4">Raw Alarms</Typography>
      <Typography>Loading…</Typography>
    </Container>
  );

  return (
    <Container maxWidth={false} sx={{ p: 0, height: '100vh', overflow: 'auto' }}>
      {/* Header */}
      <Box sx={{
        display: 'flex', alignItems: 'center', justifyContent: 'space-between',
        bgcolor: 'background.paper', p: 2, borderBottom: 1, borderColor: 'divider'
      }}>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <TableChartIcon fontSize="large" />
          <Typography variant="h4">Raw Alarms Analysis</Typography>
        </Box>
        <Box sx={{ display: 'flex', gap: 2 }}>
          <Link href="/"><DashboardIcon /> Dashboard</Link>
          <Link href="/alarms"><TableChartIcon /> Raw Alarms</Link>
        </Box>
      </Box>

      {/* Filters */}
      <Box sx={{ p: 2 }}>
        <Filters
          filters={filters}
          setFilters={setFilters}
          regionOptions={regionOptions}
          locationOptions={locationOptions}
          doorOptions={doorOptions}
          employeeOptions={employeeOptions}
          priorityOptions={priorityOptions}
          rejectionOptions={rejectionOptions}
        />
      </Box>

      {/* View toggle */}
      <Box sx={{ p: 2, display: 'flex', gap: 2 }}>
        <Button
          variant={view==='employee'?'contained':'outlined'}
          onClick={() => setView('employee')}
        >Employee Analysis</Button>
        <Button
          variant={view==='door'?'contained':'outlined'}
          onClick={() => setView('door')}
        >Door Analysis</Button>
        <Button
          variant={view==='detailed'?'contained':'outlined'}
          onClick={() => setView('detailed')}
        >Detailed Records</Button>
      </Box>

      {/* Table */}
      <Box sx={{ p: 2 }}>
        <AlarmsTable alarms={filtered} maxRows={100} tableType={view} />
      </Box>
    </Container>
  );
}





