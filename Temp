Now update Location Wise chart ...
use Line chart for Location wise.
At the top display Which Colour are use for Which location Adjust X & Y Axis for count and date or month 
Read below file carefully and update file as per my request.

File 1 Charts.js


import React, { useEffect, useRef } from 'react';
import Chart from 'chart.js/auto';

export default function MyChart({
  type = 'bar',
  data,
  options = {},
  width = '100%',
  height = 400
}) {
  const canvasRef = useRef(null);
  const chartRef  = useRef(null);

  useEffect(() => {
    if (!canvasRef.current) return;
    const ctx = canvasRef.current.getContext('2d');
    if (chartRef.current) chartRef.current.destroy();

    // Build dataset with line-chart specifics if needed
    const ds = {
      label: data.label || '',
      data: data.values,
      backgroundColor: data.bgColors,
      borderColor: data.borderColor,
      borderWidth: 2,
      fill: type === 'line' ? false : true,
      tension: type === 'line' ? 0.4 : 0,
      pointBackgroundColor: data.borderColor,
      pointRadius: type === 'line' ? 4 : undefined,
    };

    chartRef.current = new Chart(ctx, {
      type,
      data: {
        labels: data.labels,
        datasets: [ds],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        ...options,
      }
    });

    return () => chartRef.current && chartRef.current.destroy();
  }, [type, data, options]);

  return (
    <div style={{ width, height }}>
      <canvas ref={canvasRef} />
    </div>
  );
}



File 2

SummaryCards.js


import React from 'react';
import './SummaryCards.css';
import MyChart from './Chart';
import { Card, CardContent, Typography, Grid } from '@mui/material';

// Default palette for everything except priorityWise
const DEFAULT_COLORS = [
  '#007bff', '#28a745', '#ffc107',
  '#dc3545', '#6f42c1', '#17a2b8',
  '#fd7e14', '#20c997', '#6c757d',
  '#6610f2',
];

// Custom palette for priorityWise
const PRIORITY_COLORS = {
  Low: '#90ee90',    // light green
  Medium: '#ffff00', // yellow
  High: '#ff0000',   // red
};

export default function SummaryCards({ summary, filters }) {
  if (!summary) return null;

  // Build data for any key
  const makeData = (key, obj) => {
    // labels, sorted for monthWise
    let labels = Object.keys(obj);
    if (key === 'monthWise') {
      labels = labels.sort((a, b) => {
        const [mA, yA] = a.split('-').map(Number);
        const [mB, yB] = b.split('-').map(Number);
        return new Date(yA, mA - 1) - new Date(yB, mB - 1);
      });
    }
    const values = labels.map(lbl => obj[lbl].count);

    // colors
    let bg, borderColor;
    if (key === 'priorityWise') {
      bg = labels.map(lbl => PRIORITY_COLORS[lbl] || '#ccc');
      borderColor = bg;
    } else if (key === 'monthWise') {
      bg = labels.map(() => 'rgba(0,123,255,0.2)');
      borderColor = '#007bff';
    } else {
      bg = labels.map((_, i) => DEFAULT_COLORS[i % DEFAULT_COLORS.length]);
      borderColor = bg;
    }

    return { labels, values, bgColors: bg, borderColor };
  };

  // Partition: global vs region
  const partitionObj = filters.region
    ? { [filters.region]: summary.regionWise[filters.region] }
    : summary.regionWise;

  // Chart configs in desired order
  const configs = [
    { key: 'partition',        title: !filters.region ? 'Global Partition' : `${filters.region} Partition`, type: 'doughnut', dataObj: partitionObj },
    { key: 'priorityWise',     title: 'Priority Wise',      type: 'pie',      dataObj: summary.priorityWise },
    { key: 'rejectionTypeWise',title: 'Rejection Type Wise', type: 'pie',      dataObj: summary.rejectionTypeWise },
    { key: 'operatorWise',     title: 'Operator Wise',      type: 'bar',      dataObj: summary.operatorWise },
    { key: 'monthWise',        title: 'Month Wise',         type: 'line',     dataObj: summary.monthWise },
    filters.region && { key: 'locationWise', title: 'Location Wise', type: 'pie', dataObj: summary.locationWise }
  ].filter(Boolean);

  return (
    <Grid container spacing={2}>
      {configs.map(({ key, title, type, dataObj }) => {
        if (!dataObj || Object.keys(dataObj).length === 0) return null;

        // monthWise axis labels
        const options = key === 'monthWise' ? {
          scales: {
            x: { title: { display: true, text: 'Month' } },
            y: { title: { display: true, text: 'Alarm Count' } }
          }
        } : {};

        return (
          <Grid item xs={12} md={4} key={key}>
            <Card>
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  {title}
                </Typography>
                <MyChart
                  type={type}
                  data={makeData(key, dataObj)}
                  options={options}
                  height={240}
                />
              </CardContent>
            </Card>
          </Grid>
        );
      })}
    </Grid>
  );
}


Dashboard.js



// src/pages/Dashboard.js
import React, { useEffect, useState, useMemo, useRef } from 'react';
import { Container, Typography } from '@mui/material';
import Filters      from '../components/Filters';
import SummaryCards from '../components/SummaryCards';
import AlarmCard    from '../components/AlarmCard';
import { getAlarmSummary, getRawAlarms } from '../services/api';

export default function Dashboard() {
  const [summary, setSummary]     = useState(null);
  const [rawAlarms, setRawAlarms] = useState([]);
  const [filters, setFilters]     = useState({ region: '', location: '' });

  // 1) Fetch data once
  useEffect(() => {
    Promise.all([ getAlarmSummary(), getRawAlarms() ])
      .then(([sumRes, rawRes]) => {
        setSummary(sumRes.data);
        setRawAlarms(rawRes.data);
      })
      .catch(console.error);
  }, []);

  // 2) Memoize regionOptions so it only changes when summary changes
  const regionOptions = useMemo(() => {
    return summary ? Object.keys(summary.regionWise) : [];
  }, [summary]);

  // 3) Build a map of region → [locations], memoized on rawAlarms and regionOptions
  const regionLocationsMap = useMemo(() => {
    const map = {};
    regionOptions.forEach(region => {
      map[region] = Array.from(
        new Set(
          rawAlarms
            .filter(a => a.Region === region)
            .map(a => a.Location)
        )
      );
    });
    return map;
  }, [rawAlarms, regionOptions]);

  // 4) Build and start slideshow as soon as summary is available
  const slidesRef = useRef([]);
  const slideIdx  = useRef(0);

  useEffect(() => {
    if (!summary) return;   // wait for data

    // Build slides: global → each region → each location
    const slides = [{ region: '', location: '' }];
    regionOptions.forEach(region => {
      slides.push({ region, location: '' });
      regionLocationsMap[region].forEach(location => {
        slides.push({ region, location });
      });
    });
    slidesRef.current = slides;
    slideIdx.current = 0;

    // Immediately show “Global”
    setFilters(slides[0]);

    // Every 60s, advance to the next slide
    const intervalId = setInterval(() => {
      slideIdx.current = (slideIdx.current + 1) % slidesRef.current.length;
      setFilters(slidesRef.current[slideIdx.current]);
    }, 30_000);

    return () => clearInterval(intervalId);
  }, [summary, regionOptions, regionLocationsMap]);

  // 5) Compute filteredSummary exactly as before
  const filteredSummary = useMemo(() => {
    if (!summary) return null;
    const fs = { ...summary };
    if (filters.region) {
      fs.regionWise   = { [filters.region]: summary.regionWise[filters.region] };
      fs.locationWise = {};
      (regionLocationsMap[filters.region] || [])
        .filter(loc => !filters.location || loc === filters.location)
        .forEach(loc => {
          fs.locationWise[loc] = summary.locationWise[loc];
        });
    }
    return fs;
  }, [summary, filters, regionLocationsMap]);

  // 6) Render
  if (!summary) {
    return <Typography>Loading dashboard…</Typography>;
  }

  return (
    <Container sx={{ py: 4 }}>
      <Typography variant="h4" gutterBottom>
        Alarm Analysis Dashboard
      </Typography>

      <Filters
        filters={filters}
        setFilters={setFilters}
        regionOptions={regionOptions}
        locationOptions={filters.region ? regionLocationsMap[filters.region] : []}
      />

      <AlarmCard summary={summary} />

      <SummaryCards
        summary={filteredSummary}
        filters={filters}
      />
    </Container>
  );
}





